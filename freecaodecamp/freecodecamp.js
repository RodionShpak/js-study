// ###########################################################################################################################################################

// // ==========================================Task-1 // Доступ до багатовимірних масивів за допомогою індексів

// Багатовимірні масиви можна також описати як масиви в масивах.Коли ви використовуєте дужки для доступу до масиву,
// перша пара дужок відноситься до матеріалів зовнішнього(перший рівень) масиву,
//     і кожна додаткова пара дужок стосується наступного рівня матеріалів.

//     Наприклад

// const arr = [
//     [1, 2, 3],
//     [4, 5, 6],
//     [7, 8, 9],
//     [[10, 11, 12], 13, 14]
// ];

// arr[3];
// arr[3][0];
// arr[3][0][1];
// arr[3] є[[10, 11, 12], 13, 14], arr[3][0] є[10, 11, 12], і arr[3][0][1] є 11.

// Примітка: ніколи не вставляйте пробіл між ім'ям масиву і квадратними дужками,
// наприклад, так array[0][0] і навіть так array[0][0] не можна робити.
// Незважаючи на те, що для JavaScript це є дрібницею, ця звичка може ускладнити читання коду іншими програмістами.

// // // --------------------===================== Conditions =====================--------------------
// За допомогою квадратних дужок виберіть елемент із myArray таким чином, щоб myData дорівнював 8.

// // // --------------------===================== Tests =====================--------------------
// myData має дорівнювати 8.
// Waiting:Ви маєте використовувати квадратні дужки, щоб зчитати правильне значення з myArray.

// // // --------------------===================== Result =====================--------------------
// const myArray = [
//     [1, 2, 3],
//     [4, 5, 6],
//     [7, 8, 9],
//     [[10, 11, 12], 13, 14],
// ];

// const myData = myArray[2][1];



// ###########################################################################################################################################################

// // ==========================================Task-2 // push() додає дані до кінця масиву
// Керування масивами за допомогою push()
// Найпростіший спосіб додати дані до кінця масиву - це використати функцію push().

// .push() приймає один або більше parameters і "виштовхує" їх в кінець масиву.

//     Приклади:

// const arr1 = [1, 2, 3];
// arr1.push(4);

// const arr2 = ["Stimpson", "J", "cat"];
// arr2.push(["happy", "joy"]);
// arr1 зараз набуває значення[1, 2, 3, 4] та arr2 набуває значення["Stimpson", "J", "cat", ["happy", "joy"]].

// // // --------------------===================== Conditions =====================--------------------
// Виштовхніть["dog", 3] в кінець змінної myArray.

// const myArray = [["John", 23], ["cat", 2]];

// // // --------------------===================== Tests =====================--------------------
// myArray тепер має дорівнювати[["John", 23], ["cat", 2], ["dog", 3]].

// // // --------------------===================== Result =====================--------------------
// const myArray = [["John", 23], ["cat", 2]];

// // Змініть код лише під цим рядком
// myArray.push(["dog", 3]);



// ###########################################################################################################################################################

// // ==========================================Task-3 pop() змінити дані у масиві
// Керування масивами за допомогою pop()
// Іншим способом змінити дані у масиві можна за допомогою функції.pop().

// .pop() використовується для виведення значення з кінця масиву.Ми можемо зберігати значення, яке виводиться, присвоюючи його змінній.
// Іншими словами, .pop() видаляє останній елемент з масиву і повертає цей елемент.

//     Будь - який тип запису може бути виведений з масиву - цифри, рядки, навіть вкладені масиви.

// const threeArr = [1, 4, 6];
// const oneDown = threeArr.pop();
// console.log(oneDown);
// console.log(threeArr);
// Перший console.log відображатиме значення 6, а другий - значення[1, 4].

// // // --------------------===================== Conditions =====================--------------------
// Використовуйте функцію.pop(), щоб видалити останній елемент з myArray та призначити значення, яке виводиться для removedFromMyArray.

// // // --------------------===================== Tests =====================--------------------
// myArray повинен містити лише[["John", 23]].
// Waiting:Вам слід використовувати pop() на myArray.
// Waiting:removedFromMyArray повинен містити лише["cat", 2].

// // // --------------------===================== Result =====================--------------------
// const myArray = [["John", 23], ["cat", 2]];
// // Змініть код лише під цим рядком
// const removedFromMyArray = myArray.pop();



// ###########################################################################################################################################################

// // ==========================================Task-4 shift() видаляє останній елемент масиву
// Керування масивами за допомогою shift()
// pop() завжди видаляє останній елемент масиву.А якщо ти хочеш видалити перший ?

//     Саме тут нам на допомогу може прийти.shift().Це працює точно так як.pop(),
//         за винятком того, що видаляє перший елемент замість останнього.

//         Наприклад:

// const ourArray = ["Stimpson", "J", ["cat"]];
// const removedFromOurArray = ourArray.shift();
// removedFromOurArray матиме значення рядка Stimpson та ourArray отримає["J", ["cat"]].

// // // --------------------===================== Conditions =====================--------------------
// Використовуйте функцію.shift(), щоб видалити перший елемент з myArray
// та призначивши значення "викреслено" для нової змінної removedFromMyArray.

// // // --------------------===================== Tests =====================--------------------
// myArray має дорівнювати[["dog", 3]].
//     Waiting:removedFromMyArray повинен містити["John", 23].

// // // --------------------===================== Result =====================--------------------
// const myArray = [["John", 23], ["dog", 3]];

// // Змініть код лише під цим рядком
// const removedFromMyArray = myArray.shift();



// ###########################################################################################################################################################

// // ==========================================Task-5 unshift() додає елемент з початку масиву
// Керування масивами за допомогою unshift()
// Ви можете не лише shift елементи з початку масиву, ви також можете unshift елементи на початок масиву, тобто додати елементи перед масивом.

// .unshift() працює в точності як.push(), але замість додавання елемента в кінець масиву, unshift() додає елемент на початку масиву.

//     Наприклад:

// const ourArray = ["Stimpson", "J", "cat"];
// ourArray.shift();
// ourArray.unshift("Happy");
// Після shift, ourArray матиме значення["J", "cat"].Після unshift, ourArray матиме значення["Happy", "J", "cat"].

// // // --------------------===================== Conditions =====================--------------------
    // Додайте["Paul", 35] на початок змінної myArray, використовуючи unshift().

// // // --------------------===================== Tests =====================--------------------
// myArray тепер має мати[["Paul", 35], ["dog", 3]].

// // // --------------------===================== Result =====================--------------------
// const myArray = [["John", 23], ["dog", 3]];
// myArray.shift();

// // Змініть код лише під цим рядком
// myArray.unshift(["Paul", 35]);



// ###########################################################################################################################################################

// // ==========================================Task-6 // Список покупок

// Створіть список покупок у змінній myList.Список повинен бути багатовимірним масивом, який містить декілька підмасивів.

// Перший елемент у кожному підмасиві повинен містити рядок з назвою одиниці.
// Другий елемент повинен бути числом, яке відображає кількість.

// ["Chocolate Bar", 15]
// // // --------------------===================== Conditions =====================--------------------
// У списку повинно бути щонайменше 5 підмасивів.

// // // --------------------===================== Tests =====================--------------------
// myList повинен бути масивом.
// Waiting:Першими елементами у кожному з ваших підмасивів повинні бути рядки.
// Waiting:Другими елементами у кожному підмасиві повинні бути числа.
// Waiting:У списку має бути щонайменше 5 одиниць.

// // // --------------------===================== Result =====================--------------------
// const myList = [["Mango", 3], ["Peach", 5], ["Banana", 9], ["Orange", 4], ["Kiwi", 7]];



// ###########################################################################################################################################################

// // ==========================================Task-7 // Створення багаторазового коду JavaScript за допомогою функцій

// У JavaScript, ми можемо розділити наш код на повторно використовувані частини, які називаються functions.

// Приклад функції:

// function functionName() {
//     console.log("Hello World");
// }
// Ви можете викликати або invoke цю функцію, використавши дужки для написання її назви так: functionName();.
// Щоразу як ви викликатимете функцію, на екран буде виводитись повідомлення з написом Hello World на консолі розробника.
// Щоразу як буде викликана функція, увесь код між фігурними дужками буде виконуватись.

// // // --------------------===================== Conditions =====================--------------------
// Створіть функцію, яка називається reusableFunction, що друкує рядок Hi World на консоль розробників.
// Викличте функцію.

// // // --------------------===================== Tests =====================--------------------
// reusableFunction повинен бути функцією.
// Waiting:Якщо reusableFunction буде викликано, то він має виводити рядок Hi World на консоль.
// Waiting:Викличте функцію reusableFunction після її визначення.

// // // --------------------===================== Result =====================--------------------
// function reusableFunction() {
//     console.log("Hi World");
// }
// reusableFunction();



// ###########################################################################################################################################################

// // ==========================================Task-8 // Передача значень до функцій з аргументами

// Параметри - це змінні, які діють як місця для заповнення тих значень, які вводяться у функцію під час її виклику.
// Коли функцію визначають, її зазвичай визначають разом з одним або декількома параметрами.
// Реальні значення, які введені(або "передані") до функції під час її виклику, називаються аргументами.

// Ось функція з двома параметрами, param1 and param2:

// function testFun(param1, param2) {
//     console.log(param1, param2);
// }
// Потім ми можемо викликати testFun, отак: testFun("Hello", "World");.
// Ми передали два рядкові аргументи: Hello and World.
// Всередині функції, param1 дорівнюватиме рядку Hello, а param2 дорівнюватиме рядку World.
// Зверніть увагу на те, що ви можете викликати testFun знову,
// використовуючи різні аргументи та параметри, які візьмуть значення нових аргументів.

// // // --------------------===================== Conditions =====================--------------------
// Створіть функцію з назвою functionWithArgs, яка приймає 2 аргументи і виводить їхню суму в dev - консоль.
// Викличте функцію з двома числами так, як аргументи.

// // // --------------------===================== Tests =====================--------------------
// functionWithArgs має бути функцією.
//     Waiting: functionWithArgs(1, 2) має вивести 3.
// Waiting: functionWithArgs(7, 9) має вивести 16.
// Waiting:Вам слід викликати functionWithArgs з двома числами після того як визначите його.

// // // --------------------===================== Result =====================--------------------
// function functionWithArgs(param1, param2) {
//     console.log(param1 + param2);
// }
// functionWithArgs(1, 2); // 3
// functionWithArgs(7, 9); // 16



// ###########################################################################################################################################################

// // ==========================================Task-9 // Повернути значення за допомогою функції повернення

// Ми можемо передати значення у функцію за допомогою аргументів.
// Ви можете використати команду return, щоб надіслати значення назад за межі фунції.

//     Наприклад

// function plusThree(num) {
//     return num + 3;
// }

// const answer = plusThree(5);
// answer набуває значення 8.

// plusThree приймає аргумент для num і повертає значення, яке дорівнює num + 3.

// // // --------------------===================== Conditions =====================--------------------
// Створіть функцію timesFive, що приймає один аргумент, множить його на 5 і повертає нове значення.

// // // --------------------===================== Tests =====================--------------------
// timesFive має бути функцією
// Waiting: timesFive(5) має повернутися до 25
// Waiting: timesFive(2) має повернутися до 10
// Waiting: timesFive(0) має повернутися до 0

// // // --------------------===================== Result =====================--------------------
// function timesFive(num) {
//     return num * 5;
// }
// const answer = timesFive(5); // 25
// const answer = timesFive(2); // 10
// const answer = timesFive(0); // 0



// ###########################################################################################################################################################

// // ==========================================Task-10 // Глобальна область видимості та функції

// У JavaScript, область видимості стосується видимості змінних.
// Змінні, які знаходяться за межами функції, мають Глобальну область видимості.
// Це означає, що їх можна побачити всюди у вашому коді в JavaScript.

// Змінні, які оголошуються без ключових слів let чи const автоматично створюються в global області видимості.
// Це може створити непередбачувані наслідки десь у вашому коді або при запуску функції знову.
// Ви повинні завжди визначати свої змінні за допомогою let чи const.

// // // --------------------===================== Conditions =====================--------------------
// Використовуючи let чи const, визначте глобальну змінну myGlobal поза будь-якою функцією.Привласніть їй значення 10.
// Призначте 5 для oopsGlobal всередині функції fun1 не використовуючи ключове слово let чи const.

// // // --------------------===================== Tests =====================--------------------
// myGlobal краще визначити
// Waiting:myGlobal повинне мати значення 10
// Waiting:Для визначення myGlobal потрібно використати ключове слово let чи const
// Waiting: oopsGlobal має бути глобальною змінною і мати значення 5

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //

// Вкажіть змінну myGlobal під цим рядком
// function fun1() {
//     // Призначте 5 oopsGlobal тут
// }
// // Змініть код лише над цим рядком
// function fun2() {
//     var output = "";
//     if (typeof myGlobal != "undefined") {
//         output += "myGlobal: " + myGlobal;
//     }
//     if (typeof oopsGlobal != "undefined") {
//         output += " oopsGlobal: " + oopsGlobal;
//     }
//     console.log(output);
// }

                                                // AFTER //

// // Вкажіть змінну myGlobal під цим рядком
// let myGlobal = 10;
// function fun1() {
//     // Призначте 5 oopsGlobal тут
//     oopsGlobal = 5;
// }
// // Змініть код лише над цим рядком
// function fun2() {
//     var output = "";
//     if (typeof myGlobal != "undefined") {
//         output += "myGlobal: " + myGlobal;
//     }
//     if (typeof oopsGlobal != "undefined") {
//         output += " oopsGlobal: " + oopsGlobal;
//     }
//     console.log(output);
// }



// ###########################################################################################################################################################

// // ==========================================Task-11 // Локальна область видимості та функції

// Змінні, що є зазначені в межах функції, мають діапазон local, так як і параметри функції.
// Це означає, що вони є видимими лише в межах цієї функції.

// Це функція myTest з локальною змінною loc.

// function myTest() {
//     const loc = "foo";
//     console.log(loc);
// }

// myTest();
// console.log(loc);
// Виклик функції myTest() відображатиме рядок foo в консолі.
// Рядок console.log(loc) видасть помилку, тому що loc не є визначеним за діапазоном функції.

// // // --------------------===================== Conditions =====================--------------------
// Редактор має два console.log щоб допомогти вам побачити, що відбувається.
// Позначте консоль як ваш код, щоб побачити як вона змінюється.
// Зазначте локальну змінну e myVar всередині myLocalScope і запустіть тест.

// Консоль Note: все ще відображатиме ReferenceError: myVar is not defined, але це не спричинить збій тестувань.

// // // --------------------===================== Tests =====================--------------------
// Код не повинен містити глобальну змінну myVar.
// Waiting:Вам слід додати локальну змінну myVar.

// // // --------------------===================== Result =====================--------------------
// function myLocalScope() {
//     // Змініть код лише під цим рядком
//     const myVar = "";
//     console.log('inside myLocalScope', myVar);
// }
// myLocalScope();
// // Запустіть та перевірте консоль
// // myVar не визначений за межеми myLocalScope
// console.log('outside myLocalScope', myVar);



// ###########################################################################################################################################################

// // ==========================================Task-12 // Глобальна та Локальна Область видимості в роботі

// Локальні та глобальні змінні можна використовувати з одним і тим самим іменем.
// Коли ви це зробите, локальна змінна має перевагу над глобальною змінною.

// У цьому прикладі:

// const someVar = "Hat";

// function myFun() {
//     const someVar = "Head";
//     return someVar;
// }
// Функція myFun поверне рядок Head, оскільки присутній місцевий варіант змінної.

// // // --------------------===================== Conditions =====================--------------------
// Додайте локальну змінну до функції myOutfit, щоб перевизначити значення outerWear з рядком sweater.

// // // --------------------===================== Tests =====================--------------------
// Краще не змінювати значення глобального outerWear.
// Waiting:myOutfit має повертати рядок sweater.
// Waiting:Не можна змінювати оператор повернення.

// // // --------------------===================== Result =====================--------------------
// const outerWear = "T-Shirt";
// function myOutfit() {
//     // Змініть код лише під цим рядком
//     const outerWear = "sweater";
//     // Змініть код лише над цим рядком
//     return outerWear;
// }
// myOutfit();



// ###########################################################################################################################################################

// // ==========================================Task-13
// Розуміння невизначеного значення, яке повернуто з функції
// Функція може містити команду return, але не обов'язково.
// У цьому випадку функція не має команди return.
//     Натомість, коли ви викликаєте її, функція обробляє внутрішній код, але повернене значення є undefined.

//         Приклад

// let sum = 0;

// function addSum(num) {
//     sum = sum + num;
// }

// addSum(3);
// addSum - це функція без команди return.Функція змінить загальну sum(суму) змінної, але повернене значення функції буде undefined.

// // // --------------------===================== Conditions =====================--------------------
// Створіть функцію addFive без аргументів.Ця функція додає 5 до sum(суми) змінної, але повернене значення є undefined.

// // // --------------------===================== Tests =====================--------------------
// addFive має бути функцією.
    // Waiting:Після запуску обидвох функцій, sum має дорівнювати 8.
// Waiting:Повернене з addFive значення, має бути undefined.
    // Waiting:Всередині функції addFive вам слід додати 5 до sum змінної.

// // // --------------------===================== Result =====================--------------------
// let sum = 0;
// function addThree() {
//     sum = sum + 3;
// }
// // Змініть код лише під цим рядком
// function addFive() {
//     sum = sum + 5;
// }
// // Змініть код лише над цим рядком
// addThree();
// addFive();



// ###########################################################################################################################################################

// // ==========================================Task-14
// Призначення з поверненим значенням
// Якщо Ви пригадаєте з нашого обговорення Storing Values with the Assignment Operator, все,
//     що знаходиться справа від знака рівності визначається ще до того, як присвоюється значення.
//     Це означає, що ми можемо взяти повернене значення функції та присвоїти її змінній.

//     Припустимо, у нас уже є визначена функція sum, яка додає два числа, тоді:

// ourSum = sum(5, 12);
// вона називатиметься функцією sum, яка повертає значення 17 і призначає її змінній ourSum.

// // // --------------------===================== Conditions =====================--------------------
// Назвіть функцію processArg з аргументом 7 і присвойте її повернене значення змінній processed.

// // // --------------------===================== Tests =====================--------------------
// processed повинне мати значення 2
// Waiting:processArg потрібно призначити processed

// // // --------------------===================== Result =====================--------------------
// let processed = 0;
// function processArg(num) {
//     return (num + 3) / 5;
// }
// // Змініть код лише під цим рядком
// processed = processArg(7);



// ###########################################################################################################################################################

// // ==========================================Task-15
// Стояти в черзі
// В комп'ютерних науках queue це абстрактне поняття Data Structure, де усі елементи зберігають певний порядок.
// Нові елементи можуть бути додані до черги, а старі елементи - зняті з черги.

// // // --------------------===================== Conditions =====================-------------------
// Напишіть функцію nextInLine, аргументами якої є масив(arr) та число(item).
// Додайте число до кінця масиву, а тоді видаліть перший елемент з масиву.
// Функція nextInLine повинна повернути видалений елемент.

// // // --------------------===================== Tests =====================--------------------
// nextInLine([], 5) має повернути до числа.
// Waiting: nextInLine([], 1) має повернути до 1
// Waiting: nextInLine([2], 1) має повернути до 2
// Waiting: nextInLine([5, 6, 7, 8, 9], 1) має повернути до 5
// Waiting:Після nextInLine(testArr, 10), код testArr[4] має стати 10

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //

// function nextInLine(arr, item) {
//     // Змініть код лише під цим рядком
//     return item;
//     // Змініть код лише над цим рядком
// }
// // Налаштування
// const testArr = [1, 2, 3, 4, 5];
// // Відобразити код
// console.log("Before: " + JSON.stringify(testArr));
// console.log(nextInLine(testArr, 6));
// console.log("After: " + JSON.stringify(testArr));

                                                // AFTER //

// function nextInLine(arr, item) {
//     arr.push(item);
//     const removed = arr.shift();
//     return removed;
// }
// const testArr = [1, 2, 3, 4, 5];
// console.log("Before: " + JSON.stringify(testArr));
// console.log(nextInLine(testArr, 6));
// console.log("After: " + JSON.stringify(testArr));



// ###########################################################################################################################################################

// // ==========================================Task-16 // Розуміння булевих значень

// Інший тип даних це Boolean.Булеві значення можуть мати лише два значення: true чи false.
// Фактично, це маленькі перемикачі, де true це "увімкнено" і false - "вимкнено".
// Ці два стани несумісні.

// Note: Булеві вирази ніколи не записуються в дужках.Рядки "true" й "false" не булеві і не мають особливого значення в JavaScript.

// // // --------------------===================== Conditions =====================--------------------
// Змініть функцію welcomeToBooleans так, щоб вона повертала true замість false, коли натискається кнопка запуску.

// // // --------------------===================== Tests =====================--------------------
// Функція welcomeToBooleans() має повернути значення(true or false).
// Waiting: welcomeToBooleans() має повернути true.

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function welcomeToBooleans() {
//     // Змініть код лише під цим рядком
//     return false; // Змініть цей рядок
//     // Змініть код лише над цим рядком
// }

                                                // AFTER //
// function welcomeToBooleans() {
//     return true;
// }



// ###########################################################################################################################################################

// // ==========================================Task-17 // Використання умовної логіки з командою if

// команди If використовуються для прийняття рішень у коді.
// Ключове слово if наказує JavaScript виконати код у фігурних дужках за певних умов, вказаних у круглих дужках.
// Ці умови ще називаються умовами Boolean і вони можуть бути лише true або false.

// Коли умова є оціненою як true, програма виконує команду у фігурних дужках.
// Коли булева умова є оцінена як false, команда у фігурних дужках не буде виконана.

//     Псевдокод

// якщо(condition is true) {
//   statement is executed
// }
// Наприклад:

// function test(myCondition) {
//     if (myCondition) {
//         return "It was true";
//     }
//     return "It was false";
// }

// test(true);
// test(false);
// test(true) повертає рядок It was true, а test(false) повертає рядок It was false.

// Коли test отримує значення true, оператор if оцінює myCondition, щоб побачити чи воно є true чи ні.
// Оскільки це true, функція повертає It was true.
// Коли test отримує значення false, myCondition є not true,
//     команда у фігурних дужках не виконується і функція повертає It was false.

// // // --------------------===================== Conditions =====================--------------------
// Створіть оператора if всередині функції, щоб повернути Yes, that was true,
//     якщо параметр wasThatTrue є true та повернути No, that was false у протилежному випадку.

// // // --------------------===================== Tests =====================--------------------
// trueOrFalse повинен бути функцією
// Waiting: trueOrFalse(true) повинен повертати рядок
// Waiting: trueOrFalse(false) повинен повертати рядок
// Waiting: trueOrFalse(true) повинен повернути рядок Yes, that was true
// Waiting: trueOrFalse(false) повинен повернути рядок No, that was false

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function trueOrFalse(wasThatTrue) {
//     // Змініть код лише під цим рядком

//     // Змініть код лише над цим рядком
// }

                                                 // AFTER //
// function trueOrFalse(wasThatTrue) {
//     if (wasThatTrue) {
//         return "Yes, that was true";
//     }
//     return "No, that was false";
// }



// ###########################################################################################################################################################

// // ==========================================Task-18 Порівняння з Оператором Рівності (==)

// У JavaScript є багато операторів порівняння.Всі ці оператори присвоюють логічне true або false значення.

// Основним є оператор рівності ==.Оператор рівності порівнює два значення і видає true, якщо вони еквівалентні, або false, якщо ні.
// Зверніть увагу, що рівність відрізняється від присвоєння(=), яке закріплює за змінною ліворуч значення праворуч від оператора.

// function equalityTest(myVal) {
//     if (myVal == 10) {
//         return "Equal";
//     }
//     return "Not Equal";
// }
// Якщо myVal рівнозначний 10, оператор рівності видає true, тож код у фігурних дужках виконається, і функція буде Equal.
// В іншому випадку, функція буде Not Equal.
// Для того, щоб JavaScript порівняв два різні типи даних(наприклад, numbers і strings), потрібно конвертувати один тип в інший.
// Це називається Перетворення Типів.Однак, після його виконання поняття порівнюються наступним чином:

// 1 == 1
// 1 == 2
// 1 == '1'
// "3" == 3
// У такому ж порядку, як вони є, ці вирази будуть оцінені, як true, false, true, і true.

// // // --------------------===================== Conditions =====================--------------------
// Додайте оператор рівності до зазначеного рядка, щоб функція визначила рядок, як Equal, коли val еквівалентна 12.

// // // --------------------===================== Tests =====================--------------------
// testEqual(10) повинен повернути рядок Not Equal
// Waiting: testEqual(12) повинен повернути рядок Equal
// Waiting: testEqual("12") повинен повернути рядок Equal
// Waiting:Слід використовувати оператор ==

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testEqual(val) {
//     if (val) { // Змініть цей рядок
//         return "Equal";
//     }
//     return "Not Equal";
// }
// testEqual(10);

                                                // AFTER //
// function testEqual(val) {
//     if (val == 12) {
//         return "Equal";
//     }
//     return "Not Equal";
// }
// testEqual(10);



// ###########################################################################################################################################################

// // ==========================================Task-19 Порівняння з Оператором Абсолютної Рівності (===)

// Абсолютна рівність(===) є аналогом оператора рівності(==).
// Однак, на відміну від оператора рівності, який намагається перетворити обидва значення в порівнянні зі звичайним типом,
// оператор абсолютної рівності не виконує перетворення типів.

// Якщо значення, які перетворюються, мають різні типи, вони вважаються нерівними і оператор абсолютної рівності видасть помилку.

//     Наприклад

// 3 === 3
// 3 === '3'
// Ці умови повертаються відповідно true та false відповідно.

// У другому прикладі, 3 є типом Number, а '3' є типом String.

// // // --------------------===================== Conditions =====================--------------------
// Використовуйте оператора абсолютної рівності з командою if, щоб функція повернула рядок Equal, коли val точно дорівнює 7.

// // // --------------------===================== Tests =====================--------------------
// testStrict(10) перетворюється в рядку на Not Equal
// Waiting: testStrict(7) перетворюється в рядку на Equal
// Waiting: testStrict("7") перетворюється в рядку на Not Equal
// Waiting:Вам слід використовувати оператора ===

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testStrict(val) {
//     if (val) { // Змініть цей рядок
//         return "Equal";
//     }
//     return "Not Equal";
// }
// testStrict(10);

                                                // AFTER //
// function testStrict(val) {
//     if (val === 7) {
//         return "Equal";
//     }
//     return "Not Equal";
// }
// testStrict(10);



// ###########################################################################################################################################################

// // ==========================================Task-20 Вчіться порівнювати різні значення (==)/(===)

// В останніх двох задачах, ми вивчили оператор рівності(==) та оператор абсолютної рівності(===).
// Пригадаймо пройдену інформацію та спробуймо використати ці оператори знову.

// Якщо ми порівнюємо значення різних типів, то оператор рівності спершу конвертує типи, а потім обраховує значення.
// Однак, оператор абсолютної рівності порівнюватиме, як тип даних, так і значення у вихідному вигляді, не конвертуючи типи.

//     Наприклад:

// 3 == '3' повертає результат true тому, що JavaScript конвертує рядок у число. 3 === '3' повертає результат false,
// оскільки ці типи є різними і конвертація не виконується.

//     Примітка: В JavaScript, ви можете визначити тип змінної або значення за допомогою оператора typeof, наступним чином:

// typeof 3
// typeof '3'
// typeof 3 повертає рядок number, а typeof '3' повертає рядок string.

// // // --------------------===================== Conditions =====================--------------------
// Функція compareEquality в редакторі порівнює два значення за допомогою оператора рівності.
// Змініть функцію так, щоб вона повернула рядок Equal лише тоді, коли значення абсолютно рівні.

// // // --------------------===================== Tests =====================--------------------
// compareEquality(10, "10") повинне повернути рядок Not Equal
// Waiting: compareEquality("20", 20) повинне повернути рядок Not Equal
// Waiting:Слід використовувати оператор ===

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function compareEquality(a, b) {
//     if (a == b) { // Змініть цей рядок
//         return "Equal";
//     }
//     return "Not Equal";
// }
// compareEquality(10, "10");

                                                // AFTER //
// function compareEquality(a, b) {
//     if (a === b) {
//         return "Equal";
//     }
//     return "Not Equal";
// }
// compareEquality(10, "10");



// ###########################################################################################################################################################

// // ==========================================Task-21 Порівняння з Оператором "Не дорівнює" (!=)

// Оператор "не дорівнює"(!=) є протилежним до оператора рівності.
// Це означає, що вирази не еквівалентні і що вони повернуться false, де рівність повернеться true і навпаки.
// Так само, як і оператор рівності, оператор "не дорівнює" конвертує типи даних під час їх порівняння.

//     Наприклад

// 1 != 2
// 1 != "1"
// 1 != '1'
// 1 != true
// 0 != false
// У такому ж порядку, як вони є, ці вирази будуть оцінені, як true, false, false, false і false.

// // // --------------------===================== Conditions =====================--------------------
// Додайте оператора нерівності != до команди if, щоб функція повернула рядок Not Equal, коли val не дорівнює 99.

// // // --------------------===================== Tests =====================--------------------
// testNotEqual(99) має повернути рядок Equal
// Waiting: testNotEqual("99") має повернути рядок Equal
// Waiting: testNotEqual(12) має повернути рядок Not Equal
// Waiting: testNotEqual("12") має повернути рядок Not Equal
// Waiting: testNotEqual("bob") має повернути рядок Not Equal
// Waiting:Слід використовувати оператор !=

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testNotEqual(val) {
//     if (val) { // Змініть цей рядок
//         return "Not Equal";
//     }
//     return "Equal";
// }
// testNotEqual(10);

                                                // AFTER //
// function testNotEqual(val) {
//     if (val != 99) {
//         return "Not Equal";
//     }
//     return "Equal";
// }
// testNotEqual(10);



// ###########################################################################################################################################################

// // ==========================================Task-22 Порівняння з Оператором Абсолютної Нерівності (!==)

// Оператор абсолютної нерівності(!==) є логічною протилежністю оператора абсолютної рівності.
// Це означає, що "Абсолютно Не Рівно" та визначається false, де абсолютна рівність визначається як true і vice versa.
// Оператор абсолютної нерівності не буде перетворювати типи даних.

//     Приклади

// 3 !== 3
// 3 !== '3'
// 4 !== 3
// У такому порядку, ці вирази будуть оцінювати, як false, true, true.

// // // --------------------===================== Conditions =====================--------------------
// Додайте оператора абсолютної нерівності до команди if, щоб функція визначила рядок Not Equal, коли val не є абсолютно рівним 17

// // // --------------------===================== Tests =====================--------------------
// testStrictNotEqual(17) перетворюється в рядку на Equal
// Waiting: testStrictNotEqual("17") перетворюється в рядку на Not Equal
// Waiting: testStrictNotEqual(12) перетворюється в рядку на Not Equal
// Waiting: testStrictNotEqual("bob") перетворюється в рядку на Not Equal
// Waiting:Вам слід використовувати оператора !==

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testStrictNotEqual(val) {
//     if (val) { // Змініть цей рядок
//         return "Not Equal";
//     }
//     return "Equal";
// }
// testStrictNotEqual(10);

                                                // AFTER //
// function testStrictNotEqual(val) {
//     if (val !== 17) {
//         return "Not Equal";
//     }
//     return "Equal";
// }
// testStrictNotEqual(10);



// ###########################################################################################################################################################

// // ==========================================Task-23 Порівняння з оператором «більше ніж» (>)

// Оператор «більше ніж» (>) порівнює значення двох чисел.
// Якщо число зліва більше за число справа, то воно повертається true.
// В іншому випадку видається результат false.

// Як і оператор «рівність», «більше ніж» перетворюватиме типи даних під час порівняння.

//     Приклади

// 5 > 3
// 7 > '3'
// 2 > 3
// '1' > 9
// По - порядку, ці вирази оцінюватимуться як true, true, false, та false.

// // // --------------------===================== Conditions =====================--------------------
// Додайте оператор «більше ніж» до вказаних рядків, щоб оператор повернення спрацював.

// // // --------------------===================== Tests =====================--------------------
// GreaterThan(0) має повернути рядок 10 або Under
// Waiting: testGreaterThan(10) має повернути рядок 10 or Under
// Waiting: testGreaterThan(11) має повернути рядок Over 10
// Waiting: testGreaterThan(99) має повернути рядок Over 10
// Waiting: testGreaterThan(100) має повернути рядок Over 10
// Waiting: testGreaterThan(101) має повернути рядок Over 100
// Waiting: testGreaterThan(150) має повернути рядок Over 100
// Waiting:Ви повинні використати оператор > принаймні двічі

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testGreaterThan(val) {
//     if (val) {  // Змініть цей рядок
//         return "Over 100";
//     }
//     if (val) {  // Змініть цей рядок
//         return "Over 10";
//     }
//     return "10 or Under";
// }
// testGreaterThan(10);

                                                // AFTER //
// function testGreaterThan(val) {
//     if (val > 100) {
//         return "Over 100";
//     }
//     if (val > 10) {
//         return "Over 10";
//     }
//     return "10 or Under";
// }
// testGreaterThan(10);



// ###########################################################################################################################################################

// // ==========================================Task-24 Порівняння з оператором «Більше ніж дорівнює» (>=)
// Оператор "більше ніж дорівнює"(>=) порівнює значення двох чисел.
// Якщо число зліва більше за число справа, тоді функція є true.
// В іншому випадку - вона false.

// Так само, як і оператор рівності, оператор "більше ніж дорівнює" конвертує типи даних під час їх порівняння.

//     Наприклад

// 6 >= 6
// 7 >= '3'
// 2 >= 3
// '7' >= 9
// У такому ж порядку, як вони є, ці вирази будуть оцінені, як true, true, false, і false.

// // // --------------------===================== Conditions =====================--------------------
// Додайте оператор "більше ніж дорівнює" до зазначених рядків, щоб оператор повернення мав сенс.

// // // --------------------===================== Tests =====================--------------------
// testGreaterOrEqual(0) повинен повернути рядок Less than 10
// Waiting: testGreaterOrEqual(9) повинен повернути рядок Less than 10
// Waiting: testGreaterOrEqual(10) повинен повернути рядок 10 or Over
// Waiting: testGreaterOrEqual(11) повинен повернути рядок 10 or Over
// Waiting: testGreaterOrEqual(19) повинен повернути рядок 10 or Over
// Waiting: testGreaterOrEqual(100) повинен повернути рядок 20 or Over
// Waiting: testGreaterOrEqual(21) повинен повернути рядок 20 or Over
// Waiting:Слід використовувати оператор >= принаймні двічі

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testGreaterOrEqual(val) {
//     if (val) {  // Змініть цей рядок
//         return "20 or Over";
//     }
//     if (val) {  // Змініть цей рядок
//         return "10 or Over";
//     }
//     return "Less than 10";
// }
// testGreaterOrEqual(10);

                                                // AFTER //
// function testGreaterOrEqual(val) {
//     if (val >= 20) {
//     }
//     if (val >= 10) {
//         return "10 or Over";
//     }
//     return "Less than 10";
// }
// testGreaterOrEqual(10);



// ###########################################################################################################################################################

// // ==========================================Task-25 Порівняння з оператором "менше ніж" (<)
// Оператор "менше ніж"(<) порівнює значення двох чисел.
// Якщо число ліворуч менше за число праворуч, то видається результат true.
// В іншому випадку видається результат false.
// Так само, як і оператор "дорівнює", оператор "менше ніж" конвертує типи даних під час їх порівняння.

//     Наприклад:

// 2 < 5
// '3' < 7
// 5 < 5
// 3 < 2
// '8' < 4
// Відповідно, ці вирази будуть оцінені як true, true, false, false, та false.

// // // --------------------===================== Conditions =====================--------------------
// Додайте оператор "менше ніж" до вказаних рядків, щоб оператор повернення спрацював.

// // // --------------------===================== Tests =====================--------------------
// testLessThan(0) повинен видати рядок Under 25
// Waiting: testLessThan(24) повинен видати рядок Under 25
// Waiting: testLessThan(25) повинен видати рядок Under 55
// Waiting: testLessThan(54) повинен видати рядок Under 55
// Waiting: testLessThan(55) повинен видати рядок 55 or Over
// Waiting: testLessThan(99) повинен видати рядок 55 or Over
// Waiting: Оператор < потрібно використати принаймні двічі

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testLessThan(val) {
//     if (val) {  // Змініть цей рядок
//         return "Under 25";
//     }
//     if (val) {  // Змініть цей рядок
//         return "Under 55";
//     }
//     return "55 or Over";
// }
// testLessThan(10);

                                                // AFTER //
// function testLessThan(val) {
//     if (val < 25) {
//         return "Under 25";
//     }
//     if (val < 55) {
//         return "Under 55";
//     }
//     return "55 or Over";
// }
// testLessThan(10);



// ###########################################################################################################################################################

// // ==========================================Task-26 Порівняння з оператором "менше або рівне"  (<=)
// Оператор "менше або рівне"(<=) порівнює значення двох чисел.
// Якщо число ліворуч є меншим, ніж число праворуч або дорівнює йому, то видається результат true.
// Якщо число ліворуч більше за число праворуч, то видається результат false.
// Так само, як і оператор рівності, оператор "менше або рівне" конвертує типи даних.

//     Наприклад:

// 4 <= 5
// '7' <= 7
// 5 <= 5
// 3 <= 2
// '8' <= 4
// Відповідно, ці вирази будуть оцінені як true, true, true, false, та false.

// // // --------------------===================== Conditions =====================--------------------
// Додайте оператор "менше або рівне до вказаних рядків, щоб оператор повернення спрацював.

// // // --------------------===================== Tests =====================--------------------
// testLessOrEqual(0) повинен повернути рядок Smaller Than or Equal to 12
// Waiting: testLessOrEqual(11) повинен повернути рядок Smaller Than or Equal to 12
// Waiting: testLessOrEqual(12) повинен повернути рядок Smaller Than or Equal to 12
// Waiting: testLessOrEqual(23) повинен повернути рядок Smaller Than or Equal to 24
// Waiting: testLessOrEqual(24) повинен повернути рядок Smaller Than or Equal to 24
// Waiting: testLessOrEqual(25) повинен повернути рядок More Than 24
// Waiting: testLessOrEqual(55) повинен повернути рядок More Than 24
// Waiting: Оператор <= потрібно використати принаймні двічі

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testLessOrEqual(val) {
//     if (val) {  // Змініть цей рядок
//         return "Smaller Than or Equal to 12";
//     }
//     if (val) {  // Змініть цей рядок
//         return "Smaller Than or Equal to 24";
//     }
//     return "More Than 24";
// }
// testLessOrEqual(10);

                                                // AFTER //
// function testLessOrEqual(val) {
//     if (val <= 12) {
//         return "Smaller Than or Equal to 12";
//     }
//     if (val <= 24) {
//         return "Smaller Than or Equal to 24";
//     }
//     return "More Than 24";
// }
// testLessOrEqual(10);



// ###########################################################################################################################################################

// // ==========================================Task-27 Порівняння з оператором (&&) - логічне і
// Трапляється, що потрібно перевіряти більше ніж одну цифру одночасно.
// Оператор "логічне і" && стає true якщо вихідні об'єкти справа та зліва від нього вірні.

// Такого ж результату можна досягнути шляхом закладання інформації всередині іншого:

// if (num > 5) {
//     if (num < 10) {
//         return "Yes";
//     }
// }
// return "No";
// результат Yes, якщо num є більшим 5 та меньшим за 10. Приклад оператора наведено нище:

// if (num > 5 && num < 10) {
//     return "Yes";
// }
// return "No";

// // // --------------------===================== Conditions =====================--------------------
// Замініть два оператора if statements одним використовуючи && оператор.
// Значення рядка буде Yes, якщо val меньше або рівне 50 та більше або рівне 25.
// В іншому випадку значення рядка стане No.

// // // --------------------===================== Tests =====================--------------------
// Використовуйте оператор && лише один раз
// Waiting:У вас має бути лише один елемент if
// Waiting: testLogicalAnd(0) перетворюється у рядку на No
// Waiting: testLogicalAnd(24) перетворюється на No
// Waiting: testLogicalAnd(25) перетворюється на Yes
// Waiting: testLogicalAnd(30) перетворюється на Yes
// Waiting: testLogicalAnd(50) перетворюється на Yes
// Waiting: testLogicalAnd(51) перетворюється на No
// Waiting: testLogicalAnd(75) перетворюється на No
// Waiting: testLogicalAnd(80) перетворюється на No

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testLogicalAnd(val) {
//     // Змініть код лише під цим рядком
//     if (val) {
//         if (val) {
//             return "Yes";
//         }
//     }
//     // Змініть код лише над цим рядком
//     return "No";
// }
// testLogicalAnd(10);

                                                // AFTER //
// function testLogicalAnd(val) {
//     if (val <= 50 && val >= 25) {
//         return "Yes";
//     }
//     return "No";
// }
// testLogicalAnd(10);



// ###########################################################################################################################################################

// // ==========================================Task-28 Порівняння з оператором логічне або (||)
// Якщо оператор logical або(||) повертає true, якщо будь - який з operands є true.
// В іншому випадку перетворюється на false.
// Оператор логічний або складається з двох символів труби(||).
// Зазвичай його можна знайти на клавіатурі між клавіш Backspace та Enter.

// Шаблон нижче повинен бути схожим з етапами вище:

// if (num > 10) {
//     return "No";
// }
// if (num < 5) {
//     return "No";
// }
// return "Yes";
// стає Yes тільки, якщо num між 5 та 10(5 та 10 включно).Приклад оператора наведено нижче:

// if (num > 10 || num < 5) {
//     return "No";
// }
// return "Yes";

// // // --------------------===================== Conditions =====================--------------------
// Об'єднайте два оператори if в один оператор який перетворить рядок Outside,
// якщо val не знаходиться в діапазоні від 10 до 20 включно.
//  В іншому випадку значення рядка стане Inside.

// // // --------------------===================== Tests =====================--------------------
// Використовуйте оператор || лише раз
// Waiting:У вас має бути лише один елемент if
// Waiting: testLogicalOr(0) перетворюється на Outside
// Waiting: testLogicalOr(9) перетворюється на Outside
// Waiting: testLogicalOr(10) перетворюється на Inside
// Waiting: testLogicalOr(15) перетворюється на Inside
// Waiting: testLogicalOr(19) перетворюється на Inside
// Waiting: testLogicalOr(20) перетворюється на Inside
// Waiting: testLogicalOr(21) перетворюється на Outside
// Waiting: testLogicalOr(25) перетворюється на Outside

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //
// function testLogicalOr(val) {
//     // Змініть код лише під цим рядком
//     if (val) {
//         return "Outside";
//     }
//     if (val) {
//         return "Outside";
//     }
//     // Змініть код лише над цим рядком
//     return "Inside";
// }
// testLogicalOr(15);

                                                // AFTER //
// function testLogicalOr(val) {
//     if (val <= 10 || val >= 20) {
//         return "Outside";
//     }
//     return "Inside";
// }
// testLogicalOr(15);



// ###########################################################################################################################################################

// // ==========================================Task-29

// // // --------------------===================== Conditions =====================--------------------

// // // --------------------===================== Tests =====================--------------------

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //

                                                // AFTER //


































                                                

// ###########################################################################################################################################################

// // ==========================================Task-30

// // // --------------------===================== Conditions =====================--------------------

// // // --------------------===================== Tests =====================--------------------

// // // --------------------===================== Result =====================--------------------

                                                // BEFORE //

                                                // AFTER //







