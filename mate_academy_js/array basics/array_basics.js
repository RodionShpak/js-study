// Масиви
// У реальному житті ми дуже часто працюємо з великою кількістю однотипних даних: слова в словнику, оцінки в журналі, товари в магазині, книги на поличці та багато іншого.В Javascript для роботи з наборами даних використовують масиви.

// const numbers = [2, 5, 3, 4, 5, 1, 3];
// const words = ['one', 'two', 'tree'];

// // Це пустий масив, в ньому поки що немає елементів
// const friends = [];

// // Так теж можна створити масив, але на практиці користуються []
// const marks = new Array(2, 5, 3, 4, 5, 1, 3)
// Так само як і в рядка, у масиву є довжина

// console.log(
//     numbers.length, // 7
//     words.length, // 3
// );
// Як і символ в рядку, отримати елемент з масиву можна за його індексом

// const numbers = [2, 5, 3, 4, 5, 1, 3];

// console.log(
//     numbers[0], // 2
//     numbers[1], // 5
//     numbers[6], // 3

//     // Якщо елемента з вказаним індексом немає, отримаємо undefined
//     numbers[10], // undefined

//     // Від'ємні індекси теж не існують
//     numbers[-2], // undefined
// );
// Перебір масиву
// Як і рядок, перебрати масив можна за індексами та по елементах

// const numbers = [2, 5, 3, 4, 5, 1, 3];

// for (let i = 0; i < numbers.length; i++) {
//     console.log(numbers[i]); // 2, 5, 3, 4, 5, 1, 3
// }

// for (const n of numbers) {
//     console.log(n); // 2, 5, 3, 4, 5, 1, 3
// }
// Вибираємо один елемент з масиву
// Якщо ми хочемо обрати один елемент з масиву за певним критерієм, можна зберігати проміжний результат до змінної.

// function getTheLongestWord(words) {
//     // Перше слово поки що найдовше
//     let theLongest = words[0];

//     // починаємо перебір з другого
//     for (let i = 1; i < words.length; i++) {
//         // якщо поточне слово довше theLongest
//         if (words[i].length > theLongest.length) {
//             // то зберігаємо його замість попереднього theLongest
//             theLongest = words[i];
//         }
//     }

//     // Повертаємо найдовше слово знайдене в циклі
//     return theLongest;
// }

// // отримаємо 'three'
// getTheLongestWord(['one', 'two', 'three', 'four', 'five']);
// Зрозуміло, що таке порівняння можливе, тільки якщо в масиві є хоча б один елемент.Якщо ж масив пустий, то треба домовитися, що повертати в цьому випадку(наприклад, пустий рядок)

// function getTheLongestWord(words) {
//     if (words.length === 0) {
//         return '';
//     }

//     // далі той же код, що й раніше
// }
// Обчислення середнього значення
// Щоб обчислити середнє значення в масиві нам треба знайти суму всіх чисел і розділити її на кількість елементів масиву

// function getAverage(numbers) {
//     // Сюди ми будемо додавати числа
//     let sum = 0;

//     for (const n of numbers) {
//         // Додаємо кожне число до суми
//         sum += n;
//     }

//     // ділимо суму на кількість чисел
//     return sum / numbers.length;
// }
// Але якщо наш масив виявиться пустим, то доведеться ділити на 0. Тому необхідно розглянути цей випадок на початку

// function getAverage(numbers) {
//     if (numbers.length === 0) {
//         return 0;
//     }

//     // далі той же код, що і раніше
// }
// Часто середні значення заокруглюють

// Math.round(x) - заокруглить x до найближчого цілого
// Math.floor(x) - заокруглить x вниз(до найближчого не більшого цілого)
// Math.ceil(x) - заокруглить x вверх(до найближчого не меншого цілого)
// function getAverage(numbers) {
//     // тут код не міняється

//     // Заокруглюємо до найближчого цілого
//     return Math.round(sum / numbers.length);
// }
// Порівнюємо елементи
// Якщо ми хочемо порівнювати сусідні елементи масиву, то можна скористатися перебором з індексом

// // Починаємо перебір з другого елемента, щоб був попередній
// for (let i = 1; i < words.length; i++) {
//     // Порівнюємо поточне та попереднє слова
//     if (words[i] > words[i - 1]) {
//         // Робимо те, що необхідно в завданні
//     }
// }
// Редагування масиву
// На відміну від символа в рядку, елемент в масиві можна замінити по індексу

// const numbers = [1, 2, 3, 4, 5];
// numbers[1] = 100;

// console.log(numbers); // [1, 100, 3, 4, 5]
// Також можна додати новий елемент

// const numbers = [1, 2, 3, 4, 5];
// numbers[5] = 100;
// console.log(numbers); // [1, 2, 3, 4, 5, 100]
// Але якщо ми вкажемо неправильний індекс, то масив буде працювати некоректно.

// const numbers = [1, 2, 3];
// numbers[5] = 100;
// console.log(numbers); // [1, 2, 3, empty, empty, 100]
// Додавання елементів до масиву
// Тому для додавання елементів до массиву є метод push

// const numbers = [1, 2, 3];
// numbers.push(100);
// console.log(numbers); // [1, 2, 3, 100]

// // Можна додати одразу декілька елементів
// numbers.push(4, 5, 6);
// console.log(numbers); // [1, 2, 3, 100, 4, 5, 6]
// Для додавання на початок масиву є метод unshift

// const numbers = [1, 2, 3];
// numbers.unshift(100);
// console.log(numbers); // [100, 1, 2, 3]

// // Можна додати одразу декілька елементів
// numbers.unshift(4, 5, 6);
// console.log(numbers); // [4, 5, 6, 100, 1, 2, 3]
// Видалення з масиву
// Метод pop видаляє останній елемент масиву, shift - перший

// const numbers = [1, 2, 3, 4, 5];
// numbers.pop();
// console.log(numbers); // [1, 2, 3, 4]

// numbers.shift();
// console.log(numbers); // [2, 3, 4]
// Створення нового масиву на базі старого
// Часто ми отримуємо на вхід масив даних і хочемо на його основі створити новий масив результатів.У цьому випадку можна використати цикл.

// // Отримуємо масив слів і повертаємо масив їх довжини
// function getWordsLengths(words) {
//     // створюємо пустий масив для результатів
//     const result = [];

//     // перебираємо початковий масив
//     for (const word of words) {
//         // обчислюємо результат для поточного елемента
//         const length = word.length;

//         // Додаємо значення до масиву результатів
//         result.push(length);
//     }

//     // повертаємо масив наповнений в циклі
//     return result;
// }

// // отримаємо [3, 3, 5, 4, 4]
// getWordsLengths(['one', 'two', 'three', 'four', 'five']);
// Фільтруємо масив
// Якщо ми хочемо створити новий масив, де будуть лише деякі елементи початкового, можна додати умову до циклу

// function getLongWords(words) {
//     const result = [];

//     for (const word of words) {
//         // перевіряємо чи підходить нам елемент
//         if (word.length > 3) {
//             // додаємо до результату тільки відповідні елементи
//             result.push(word);
//         }
//     }

//     return result;
// }
// Пошук елементів у масиві
// У масивів є методи includes, indexOf і lastIndexOf, які працюють так само, як і для рядків

// const words = ['one', 'two', 'three', 'one'];

// console.log(
//     words.includes('two'), // true
//     words.indexOf('one'), // 0
//     words.lastIndexOf('one'), // 3

//     // Не трапляється, починаючи з індекса 2
//     words.includes('two', 2), // false
//     words.indexOf('two', 2), // -1

//     // Перше входження, починаючи з індекса 1
//     words.indexOf('one', 1), // 3

//     // Перевіряється елемент повністю, а не його частина
//     words.includes('w'), // false
// );
// Отримання частини масиву
// Метод slice для масиву працює так само, як і для рядка та створює новий масив з потрібними елементами

// const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

// console.log(
//     numbers.slice(3, 8), // [3, 4, 5, 6, 7]

//     // Перші 5 елементів
//     numbers.slice(0, 5), // [0, 1, 2, 3, 4]

//     // Елементи від індекса 4 до кінця
//     numbers.slice(4), // [4, 5, 6, 7, 8, 9]

//     // Всі елементи масиву
//     numbers.slice(), // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

//     // Від'ємні індекси рахуються з кінця
//     numbers.slice(-4, -2), // [6, 7]

//     // Всі елементи, крім першого та останнього
//     numbers.slice(1, -1), // [1, 2, 3, 4, 5, 6, 7, 8]

//     // Останні 3 елементи
//     numbers.slice(-3), // [7, 8, 9]
// );