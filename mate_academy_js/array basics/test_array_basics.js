// ###########################################################################################################################################################

// // ==========================================Task-1

// Яке значення матиме змінна 'letter' ?
// const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
// const letter = letters[1];

// null

// undefined

// 'a'

// 'b'                      V

// Пояснення правильного варіанту:
// Правильний варіант - 'b', тому що 'b' має індекс 1 в масиві 'letters'.

// Індексація масивів Javascript починається з нуля.Перший елемент масиву має індекс 0. Наприклад:
// const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
// console.log(letters[0]) // виводить 'a' в консоль

// У нашій задачі нам потрібен елемент з індексом 1, який дорівнює 'b', тому змінна 'letter' матиме значення 'b'.

// Якщо елемента з таким індексом не існує в масиві, при спробі отримати його значення результатом буде undefined:
// const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
// console.log(letters[7]) // виводить undefined в консоль, тому що немає елемента з індексом 7: останній елемент - це 'g' з індексом 6

// ###########################################################################################################################################################

// // ==========================================Task-2

// Яке значення матиме змінна 'size' ?
// const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
// const size = letters.length;

// undefined

// 6

// 7                V

// null

// Пояснення правильного варіанту:
// Правильний варіант - 7, тому що в масиві 7 елементів: 'a', 'b', 'c', 'd', 'e', 'f', 'g'.
// Властивість 'length'(довжина) повертає кількість елементів у масиві.

// Якщо масив порожній, його довжина дорівнюватиме 0. Наприклад:
// const letters = [];
// console.log(letters.length) // виводить 0 в консоль

// Якщо змінна не визначена або не має властивості length, результатом використання length буде undefined.Наприклад:
// const number = 6;
// console.log(number.length) // виводить undefined в консоль, тому що у чисел немає властивості length

// const words = ['hello', 'world'];
// console.log(word.length) // виводить undefined в консоль, тому що змінної 'word' немає, тільки 'words'

// ###########################################################################################################################################################

// // ==========================================Task-3

// Як збільшити кожен елемент масиву 'numbers' на 1 ?

//     Код :

// for (let i = 0; i < numbers.length; i++) {
//     numbers[i] + 1;
// }

// Код:                                                    V

// for (let i = 0; i < numbers.length; i++) {
//     numbers[i] += 1;
// }

// Код:

// for (let i = 0; i <= numbers.length; i++) {
//     numbers[i] += 1;
// }

// Код:

// for (let i = 0; i <= numbers.length; i++) {
//     numbers[i] + 1;
// }
// Пояснення правильного варіанту:
// Правильний варіант:

// for (let i = 0; i < numbers.length; i++) {
//     numbers[i] += 1;
// }

// Ось як працює цей код:
// 1. виконується цикл від 0 до numbers.length(не включно)
// 2. на кожній ітерації елементіз 'numbers' за індексом = поточному 'i' збільшується на 1
// 3. коли i = number.length, цикл зупиняється: ми перебрали весь масив

// ⛔ Інші варіанти неправильні, тому що:
// - Якщо ми напишемо 'i <= numbers.length' в умові зупинки, буде проблема з останньою ітерацією,
// тому що немає елемента з індексом numbers.length; останній елемент має індекс number.length – 1;
// - Якщо в тілі циклу написати 'numbers[i] + 1', це не змінить елементи в масиві:
// для цього потрібно надати поточному елементу нове значення, наприклад: numbers[i] += 1 або numbers[i] = numbers[i] + 1.

// ###########################################################################################################################################################

// // ==========================================Task-4

// Як отримати останній елемент масиву ?

// array[array.length - 1]               V

// array[length - 1]

// array[length]

// array[array.length]

// Пояснення правильного варіанту:
// Правильний варіант - 'array[array.length - 1]', тому що індексація масивів у Javascript починається з нуля,
//     тому останній елемент матиме індекс array[array.length - 1].

//     Наприклад, якщо в масиві 3 елементи, вони будуть мати індекси 0, 1, 2.
//     Останній елемент має індекс зі значенням array.length - 1(3 - 1 = 2).

// ⛔ Інші варіанти неправильні, тому що:
// - Якщо ми напишемо 'array[array.length]', то отримаємо undefined,
// тому що немає елемента з індексом array.length: останній елемент знаходиться за індексом array.length - 1;
// - Якщо ми напишемо 'array[length]' або 'array[length - 1]', то незрозуміло, яку 'length'(довжину) брати, тому length буде undefined.

// ###########################################################################################################################################################

// // ==========================================Task-5

// Яке значення матиме змінна 'sum' після виконання цього коду ?
// const numbers = [2, 7, 9, 4];
// let sum = 0;

// for (const number of numbers) {
//     sum += number;
// }

// 2794

// 4

// 2

// 22                          V

// Пояснення правильного варіанту:
// Правильний варіант: 22

// Ось як працює цей код:
// 1. створюється масив 'numbers', його елементи: [2, 7, 9, 4]
// 2. оголошується змінна 'sum' зі значенням 0
// 3. цикл for...of перебирає кожен елемент з масиву 'numbers'
// 4. на кожній ітерації до 'sum' додається 'number'(поточний елемент масиву 'numbers')

// В результаті sum = 2 + 7 + 9 + 4 = 22

// ###########################################################################################################################################################

// // ==========================================Task-6

// Вибери усі можливі способи створення масиву чисел від 1 до 5:

// const numbers = { 1, 2, 3, 4, 5};

// const numbers = [1, 2, 3, 4, 5]; V

// const numbers = Array(1, 2, 3, 4, 5); V

// const numbers = new Array(1, 2, 3, 4, 5); V

// const numbers = (1, 2, 3, 4, 5);

// Пояснення правильного варіанту:
// Правильні варіанти:

// - const numbers = [1, 2, 3, 4, 5];
// - const numbers = new Array(1, 2, 3, 4, 5);
// - const numbers = Array(1, 2, 3, 4, 5);

// Усі вони створюють новий масив чисел від 1 до 5.

// ⛔ Інші варіанти неправильні, тому що:
// - Якщо ми напишемо 'const numbers = (1, 2, 3, 4, 5)', Javascript побачить тільки останнє значення у дужках,
// і значенням змінної 'numbers' буде число 5, а не масив[1, 2, 3, 4, 5];
// - Якщо ми напишемо 'const numbers = {1, 2, 3, 4, 5}', ми отримаємо помилку 'Unexpected token'('Неочікуваний знак'),
//     тому що Javascript не розуміє, чому після "{1" стоїть кома.
// Зазвичай фігурні дужки { } використовуються для функцій, if-операторів або об'єктів - ще одного типу даних в Javascript.

// ###########################################################################################################################################################

// // ==========================================Task-7

// Як знайти найкоротше слово в масиві ?

// Код :

// let theShortest = words[0];

// for (let i = 0; i < words.length; i++) {
//     if (words[i].length < theShortest.length) {
//         theShortest = words[i];
//     }
// }

// Код:

// let theShortest = words[0];

// for (let i = 1; i < words.length; i++) {
//     if (words[i].length > theShortest.length) {
//         theShortest = words[i];
//     }
// }

// Код:                                                          V

// let theShortest = words[0];

// for (let i = 1; i < words.length; i++) {
//     if (words[i].length < theShortest.length) {
//         theShortest = words[i];
//     }
// }

// Код:

// const theShortest = words[0];

// for (let i = 1; i < words.length; i++) {
//     if (words[i].length < theShortest.length) {
//         theShortest = words[i];
//     }
// }
// Пояснення правильного варіанту:
// Правильний варіант:

// let theShortest = words[0];

// for (let i = 1; i < words.length; i++) {
//     if (words[i].length < theShortest.length) {
//         theShortest = words[i];
//     }
// }

// Ось як працює цей код:
// 1. оголошується змінна 'theShortest' зі значенням, що дорівнює першому елементу масиву words(words[0])
// 2. виконується цикл від 1 до words.length(не включно)
// 3. на кожній ітерації поточний елемент порівнюється з 'theShortest':
// 3.а.якщо поточний елемент коротший за 'theShortest', його значення присвоюється 'theShortest'
// 3.b якщо ні, то нічого не відбувається і цикл продовжує виконуватись
// 4. після порівняння всіх елементів 'theShortest' буде містити значення найкоротшого слова з масиву 'words'

// ⛔ Інші варіанти неправильні, тому що:
// - Якщо ми напишемо 'const theShortest = words[0]', ми не зможемо присвоїти нове значення змінній 'theShortest',
// тому частина тіла циклу 'theShortest = words[i]' не буде виконуватися, навіть якщо умова 'words[i].length < theShortest.length' вірна;
// - Якщо ми напишемо 'words[i].length > theShortest.length' як умову для порівняння, то вона буде вірною,
// якщо поточний елемент довший, ніж 'theShortest', тому цей спосіб використовується для пошуку найдовшого слова, а не найкоротшого;
// - Якщо ми почнемо наш цикл із 0(тобто з першого елемента), перша ітерація не має сенсу,
// тому що ми порівнюємо words[0].length < words[0].length.Ось чому тут нам потрібно почати з 1(тобто з другого елемента масиву 'words').

// ###########################################################################################################################################################

// // ==========================================Task-8

// Яке значення матиме змінна 'numbers' після виконання цього коду ?
// const numbers = [];

// for (let i = 3; i <= 7; i++) {
//     numbers.push(i);
// }

// [3, 4, 5, 6, 7]                       V

// 3

// 7

// [3, 4, 5, 6]

// Пояснення правильного варіанту:
// Правильний варіант:

// [3, 4, 5, 6, 7]

// Ось як працює цей код:
// 1. створюється масив 'numbers'
// 2. виконується цикл від 3 до 7
// 3. на кожній ітерації поточне 'i' додається до масиву 'numbers'
// 4. коли i = 8, цикл зупиняється та 'i' не додається до масиву

// В результаті numbers = [3, 4, 5, 6, 7]

// ###########################################################################################################################################################

// // ==========================================Task-9

// // --------------------===================== Conditions =====================--------------------

// Напиши функцію createArray, яка приймає ціле число N і повертає масив, що містить усі цілі числа від 1 до N включно.

// Якщо N = 0, поверни порожній масив.

//     Приклади:

// createArray(1) === [1]
// createArray(3) === [1, 2, 3]
// createArray(0) === []
// Підказка
// Створи порожній масив numbers
// Створи цикл for від 1 до N
// На кожній ітерації додавай поточне i до numbers за допомогою методу push

// // --------------------===================== Result =====================--------------------
// function createArray(N) {
//     let numbers = [];
//     if (N === 0) {
//         return numbers;
//     }
//     for (let i = 1; i <= N; i++) {
//         numbers.push(i);
//     }
//     return numbers;
// };

// ###########################################################################################################################################################

// // ==========================================Task-10

// // --------------------===================== Conditions =====================--------------------

// Настав час запускати масове виробництво роботів! Щоб роботи на лінії збиралися правильно, потрібно маркувати деталі.
// Різні частини робота будуть складатися з різної кількості деталей.Давай зробимо наліпки для них!

// Напиши програму для принтера makeStickers, яка приймає число detailsCount і рядок robotPart.
// Функція повинна повертати масив рядків в такому форматі: { { robotPart } } detail #{ { n } } (наприклад Hand detail #1).

// Якщо detailsCount = 0, поверни порожній масив.

//     Приклади:

// makeStickers(3, 'Body') === ['Body detail #1', 'Body detail #2', 'Body detail #3']
// makeStickers(4, 'Head') === ['Head detail #1', 'Head detail #2', 'Head detail #3', 'Head detail #4']
// makeStickers(0, 'Foot') === []
// Підказка 1
// Створи порожній масив
// Створи цикл for від 1 до detailsCount
// На кожній ітерації додавай у масив рядок з robotPart та поточним i в правильному форматі за допомогою методу push
// Підказка 2
// Ти можеш застосувати інтерполяцію, щоб створити рядок з robotPart та поточним i в правильному форматі.
// Не забудь використати для цього зворотні лапки.

// // --------------------===================== Result =====================--------------------

// function makeStickers(detailsCount, robotPart) {
//     // write code here
//     let details = [];
//     for (let i = 1; i <= detailsCount; i++) {
//         details.push(robotPart + ` detail #` + i);
//     }
//     return details;
// }

// ###########################################################################################################################################################

// // ==========================================Task-11

// // --------------------===================== Conditions =====================--------------------

// Наліпки готові ? Добре, треба збільшити потужності наших ліній у два рази! До цього ми там тільки попкорн готували.

// Напиши функцію doublePower, яка приймає масив поточних потужностей currentPowers та повертає новий масив з подвоєними значеннями.

//     Приклади:

// doublePower([100, 150, 200, 220]) === [200, 300, 400, 440]
// doublePower([45, 34, 56, 67]) === [90, 68, 112, 134]
// doublePower([]) === []
// Підказка 1
// Створи порожній масив
// Використовуй цикл for від 0 до currentPowers.length(не включно), щоб перебрати вхідний масив
// На кожній ітерації додавай у масив i - й елемент currentPowers, помножений на 2
// Підказка 2
// Щоб отримати i - й елемент масиву, використовуй квадратні дужки(currentPowers[i])

// // --------------------===================== Result =====================--------------------

// function doublePower(currentPowers) {
//     let power = [];
//     for (let i = 0; i < currentPowers.length; i++) {
//         power.push(currentPowers[i] * 2);
//     }
//     return power;
// }

// ###########################################################################################################################################################

// // ==========================================Task-12

// // --------------------===================== Conditions =====================--------------------

// Давай навчимо наших роботів сортувати коробки на складі.Всі коробки мають номери, а роботи вчаться сортувати їх в порядку зростання.

// Але сортування — справа нелегка, іноді трапляються помилки.Тому нам поки доведеться перевіряти, чи правильно робот відсортував коробки.

// Напиши функцію isSorted, яка отримує масив чисел boxNumbers і повертає true, якщо всі числа в порядку зростання, або false, якщо це не так.
// Числа можуть повторюватись.

//     Приклади:

// isSorted([1, 2, 3, 4, 5]) === true
// isSorted([0, 1, 1, 1, 2]) === true
// isSorted([1, 2, 11]) === true
// isSorted([5]) === true
// isSorted([]) === true
// isSorted([0, 3, 1, 2, 2, 2]) === false
// isSorted([1, 11, 2]) === false
// Підказка
// Перебери масив, починаючи з другого елемента(щоб був попередній)
// На кожній ітерації порівнюй поточний елемент з попереднім
// Якщо поточний елемент менший за попередній, порядок неправильний, і можна завершити функцію —
// Якщо ми дійшли до кінця, значить, елементи впорядковані правильно

// // --------------------===================== Result =====================--------------------

// function isSorted(boxNumbers) {
//     for (let i = 1; i <= boxNumbers.length; i++) {
//         if (boxNumbers[i] < boxNumbers[i - 1]) {
//             return false
//         }
//     }
//     return true
// }

// ###########################################################################################################################################################

// // ==========================================Task-13

// // --------------------===================== Conditions =====================--------------------

// Наш робот вміє перетворювати команди руху на правильний сигнал і рухатися відповідно до нього:

// 'forward' означає y + 1
// 'back' означає y - 1
// 'right' означає x + 1
// 'left' означає x - 1
// Було б чудово, якби робот знав, де він зараз знаходиться навіть без GPS.

// Напиши функцію getLocation, яка приймає масив початкових координат coordinates(у вигляді[x, y]) та масив історії команд commands.

// Функція повинна повертати масив кінцевих координат робота в тому ж форматі([x, y]) після рухів відповідно до команд з commands.

//     Наприклад:

// coordinates = [2, 1]
// commands = ['left', 'back', 'back']

// Координати після першої команди: [1, 1] // 1 крок вліво
// Координати після другої команди: [1, 0] // 1 крок назад
// Координати після третьої команди: [1, -1] // 1 крок назад

// Результатом буде[1, -1]
// Інші приклади:

// getLocation([0, 0], ['forward', 'right']) === [1, 1]
// getLocation([2, 3], ['back', 'back', 'back', 'right']) === [3, 0]
// getLocation([0, 5], ['back', 'back', 'back', 'right', 'left', 'forward']) === [0, 3]
// Підказка
// Створи змінні x та y і присвой їм значення відповідних координат з масиву coordinates: ми змінюватимемо їх згідно з рухами робота
// Перебери масив commands
// На кожній ітерації перевіряй поточну команду:
// якщо вона дорівнює 'forward', збільшуй y на 1
// якщо вона дорівнює 'left', зменшуй x на 1, і так далі...
// Поверни масив з кінцевими значеннями x та y.

// // --------------------===================== Result =====================--------------------





















// // --------------------===================== Result =====================--------------------