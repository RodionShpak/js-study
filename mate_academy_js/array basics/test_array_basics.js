// ###########################################################################################################################################################

// // ==========================================Task-1

// Яке значення матиме змінна 'letter' ?
// const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
// const letter = letters[1];

// null

// undefined

// 'a'

// 'b'                      V

// Пояснення правильного варіанту:
// Правильний варіант - 'b', тому що 'b' має індекс 1 в масиві 'letters'.

// Індексація масивів Javascript починається з нуля.Перший елемент масиву має індекс 0. Наприклад:
// const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
// console.log(letters[0]) // виводить 'a' в консоль

// У нашій задачі нам потрібен елемент з індексом 1, який дорівнює 'b', тому змінна 'letter' матиме значення 'b'.

// Якщо елемента з таким індексом не існує в масиві, при спробі отримати його значення результатом буде undefined:
// const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
// console.log(letters[7]) // виводить undefined в консоль, тому що немає елемента з індексом 7: останній елемент - це 'g' з індексом 6

// ###########################################################################################################################################################

// // ==========================================Task-2

// Яке значення матиме змінна 'size' ?
// const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
// const size = letters.length;

// undefined

// 6

// 7                V

// null

// Пояснення правильного варіанту:
// Правильний варіант - 7, тому що в масиві 7 елементів: 'a', 'b', 'c', 'd', 'e', 'f', 'g'.
// Властивість 'length'(довжина) повертає кількість елементів у масиві.

// Якщо масив порожній, його довжина дорівнюватиме 0. Наприклад:
// const letters = [];
// console.log(letters.length) // виводить 0 в консоль

// Якщо змінна не визначена або не має властивості length, результатом використання length буде undefined.Наприклад:
// const number = 6;
// console.log(number.length) // виводить undefined в консоль, тому що у чисел немає властивості length

// const words = ['hello', 'world'];
// console.log(word.length) // виводить undefined в консоль, тому що змінної 'word' немає, тільки 'words'

// ###########################################################################################################################################################

// // ==========================================Task-3

// Як збільшити кожен елемент масиву 'numbers' на 1 ?

//     Код :

// for (let i = 0; i < numbers.length; i++) {
//     numbers[i] + 1;
// }

// Код:                                                    V

// for (let i = 0; i < numbers.length; i++) {
//     numbers[i] += 1;
// }

// Код:

// for (let i = 0; i <= numbers.length; i++) {
//     numbers[i] += 1;
// }

// Код:

// for (let i = 0; i <= numbers.length; i++) {
//     numbers[i] + 1;
// }
// Пояснення правильного варіанту:
// Правильний варіант:

// for (let i = 0; i < numbers.length; i++) {
//     numbers[i] += 1;
// }

// Ось як працює цей код:
// 1. виконується цикл від 0 до numbers.length(не включно)
// 2. на кожній ітерації елементіз 'numbers' за індексом = поточному 'i' збільшується на 1
// 3. коли i = number.length, цикл зупиняється: ми перебрали весь масив

// ⛔ Інші варіанти неправильні, тому що:
// - Якщо ми напишемо 'i <= numbers.length' в умові зупинки, буде проблема з останньою ітерацією,
// тому що немає елемента з індексом numbers.length; останній елемент має індекс number.length – 1;
// - Якщо в тілі циклу написати 'numbers[i] + 1', це не змінить елементи в масиві:
// для цього потрібно надати поточному елементу нове значення, наприклад: numbers[i] += 1 або numbers[i] = numbers[i] + 1.

// ###########################################################################################################################################################

// // ==========================================Task-4

// Як отримати останній елемент масиву ?

// array[array.length - 1]               V

// array[length - 1]

// array[length]

// array[array.length]

// Пояснення правильного варіанту:
// Правильний варіант - 'array[array.length - 1]', тому що індексація масивів у Javascript починається з нуля,
//     тому останній елемент матиме індекс array[array.length - 1].

//     Наприклад, якщо в масиві 3 елементи, вони будуть мати індекси 0, 1, 2.
//     Останній елемент має індекс зі значенням array.length - 1(3 - 1 = 2).

// ⛔ Інші варіанти неправильні, тому що:
// - Якщо ми напишемо 'array[array.length]', то отримаємо undefined,
// тому що немає елемента з індексом array.length: останній елемент знаходиться за індексом array.length - 1;
// - Якщо ми напишемо 'array[length]' або 'array[length - 1]', то незрозуміло, яку 'length'(довжину) брати, тому length буде undefined.

// ###########################################################################################################################################################

// // ==========================================Task-5

// Яке значення матиме змінна 'sum' після виконання цього коду ?
// const numbers = [2, 7, 9, 4];
// let sum = 0;

// for (const number of numbers) {
//     sum += number;
// }

// 2794

// 4

// 2

// 22                          V

// Пояснення правильного варіанту:
// Правильний варіант: 22

// Ось як працює цей код:
// 1. створюється масив 'numbers', його елементи: [2, 7, 9, 4]
// 2. оголошується змінна 'sum' зі значенням 0
// 3. цикл for...of перебирає кожен елемент з масиву 'numbers'
// 4. на кожній ітерації до 'sum' додається 'number'(поточний елемент масиву 'numbers')

// В результаті sum = 2 + 7 + 9 + 4 = 22

// ###########################################################################################################################################################

// // ==========================================Task-6

// Вибери усі можливі способи створення масиву чисел від 1 до 5:

// const numbers = { 1, 2, 3, 4, 5};

// const numbers = [1, 2, 3, 4, 5]; V

// const numbers = Array(1, 2, 3, 4, 5); V

// const numbers = new Array(1, 2, 3, 4, 5); V

// const numbers = (1, 2, 3, 4, 5);

// Пояснення правильного варіанту:
// Правильні варіанти:

// - const numbers = [1, 2, 3, 4, 5];
// - const numbers = new Array(1, 2, 3, 4, 5);
// - const numbers = Array(1, 2, 3, 4, 5);

// Усі вони створюють новий масив чисел від 1 до 5.

// ⛔ Інші варіанти неправильні, тому що:
// - Якщо ми напишемо 'const numbers = (1, 2, 3, 4, 5)', Javascript побачить тільки останнє значення у дужках,
// і значенням змінної 'numbers' буде число 5, а не масив[1, 2, 3, 4, 5];
// - Якщо ми напишемо 'const numbers = {1, 2, 3, 4, 5}', ми отримаємо помилку 'Unexpected token'('Неочікуваний знак'),
//     тому що Javascript не розуміє, чому після "{1" стоїть кома.
// Зазвичай фігурні дужки { } використовуються для функцій, if-операторів або об'єктів - ще одного типу даних в Javascript.

// ###########################################################################################################################################################

// // ==========================================Task-7

// Як знайти найкоротше слово в масиві ?

// Код :

// let theShortest = words[0];

// for (let i = 0; i < words.length; i++) {
//     if (words[i].length < theShortest.length) {
//         theShortest = words[i];
//     }
// }

// Код:

// let theShortest = words[0];

// for (let i = 1; i < words.length; i++) {
//     if (words[i].length > theShortest.length) {
//         theShortest = words[i];
//     }
// }

// Код:                                                          V

// let theShortest = words[0];

// for (let i = 1; i < words.length; i++) {
//     if (words[i].length < theShortest.length) {
//         theShortest = words[i];
//     }
// }

// Код:

// const theShortest = words[0];

// for (let i = 1; i < words.length; i++) {
//     if (words[i].length < theShortest.length) {
//         theShortest = words[i];
//     }
// }
// Пояснення правильного варіанту:
// Правильний варіант:

// let theShortest = words[0];

// for (let i = 1; i < words.length; i++) {
//     if (words[i].length < theShortest.length) {
//         theShortest = words[i];
//     }
// }

// Ось як працює цей код:
// 1. оголошується змінна 'theShortest' зі значенням, що дорівнює першому елементу масиву words(words[0])
// 2. виконується цикл від 1 до words.length(не включно)
// 3. на кожній ітерації поточний елемент порівнюється з 'theShortest':
// 3.а.якщо поточний елемент коротший за 'theShortest', його значення присвоюється 'theShortest'
// 3.b якщо ні, то нічого не відбувається і цикл продовжує виконуватись
// 4. після порівняння всіх елементів 'theShortest' буде містити значення найкоротшого слова з масиву 'words'

// ⛔ Інші варіанти неправильні, тому що:
// - Якщо ми напишемо 'const theShortest = words[0]', ми не зможемо присвоїти нове значення змінній 'theShortest',
// тому частина тіла циклу 'theShortest = words[i]' не буде виконуватися, навіть якщо умова 'words[i].length < theShortest.length' вірна;
// - Якщо ми напишемо 'words[i].length > theShortest.length' як умову для порівняння, то вона буде вірною,
// якщо поточний елемент довший, ніж 'theShortest', тому цей спосіб використовується для пошуку найдовшого слова, а не найкоротшого;
// - Якщо ми почнемо наш цикл із 0(тобто з першого елемента), перша ітерація не має сенсу,
// тому що ми порівнюємо words[0].length < words[0].length.Ось чому тут нам потрібно почати з 1(тобто з другого елемента масиву 'words').

// ###########################################################################################################################################################

// // ==========================================Task-8

// Яке значення матиме змінна 'numbers' після виконання цього коду ?
// const numbers = [];

// for (let i = 3; i <= 7; i++) {
//     numbers.push(i);
// }

// [3, 4, 5, 6, 7]                       V

// 3

// 7

// [3, 4, 5, 6]

// Пояснення правильного варіанту:
// Правильний варіант:

// [3, 4, 5, 6, 7]

// Ось як працює цей код:
// 1. створюється масив 'numbers'
// 2. виконується цикл від 3 до 7
// 3. на кожній ітерації поточне 'i' додається до масиву 'numbers'
// 4. коли i = 8, цикл зупиняється та 'i' не додається до масиву

// В результаті numbers = [3, 4, 5, 6, 7]

// ###########################################################################################################################################################

// // ==========================================Task-9

// // --------------------===================== Conditions =====================--------------------

// Напиши функцію createArray, яка приймає ціле число N і повертає масив, що містить усі цілі числа від 1 до N включно.

// Якщо N = 0, поверни порожній масив.

//     Приклади:

// createArray(1) === [1]
// createArray(3) === [1, 2, 3]
// createArray(0) === []
// Підказка
// Створи порожній масив numbers
// Створи цикл for від 1 до N
// На кожній ітерації додавай поточне i до numbers за допомогою методу push

// // --------------------===================== Result =====================--------------------
// function createArray(N) {
//     let numbers = [];
//     if (N === 0) {
//         return numbers;
//     }
//     for (let i = 1; i <= N; i++) {
//         numbers.push(i);
//     }
//     return numbers;
// };

// ###########################################################################################################################################################

// // ==========================================Task-10

// // --------------------===================== Conditions =====================--------------------

// Настав час запускати масове виробництво роботів! Щоб роботи на лінії збиралися правильно, потрібно маркувати деталі.
// Різні частини робота будуть складатися з різної кількості деталей.Давай зробимо наліпки для них!

// Напиши програму для принтера makeStickers, яка приймає число detailsCount і рядок robotPart.
// Функція повинна повертати масив рядків в такому форматі: { { robotPart } } detail #{ { n } } (наприклад Hand detail #1).

// Якщо detailsCount = 0, поверни порожній масив.

//     Приклади:

// makeStickers(3, 'Body') === ['Body detail #1', 'Body detail #2', 'Body detail #3']
// makeStickers(4, 'Head') === ['Head detail #1', 'Head detail #2', 'Head detail #3', 'Head detail #4']
// makeStickers(0, 'Foot') === []
// Підказка 1
// Створи порожній масив
// Створи цикл for від 1 до detailsCount
// На кожній ітерації додавай у масив рядок з robotPart та поточним i в правильному форматі за допомогою методу push
// Підказка 2
// Ти можеш застосувати інтерполяцію, щоб створити рядок з robotPart та поточним i в правильному форматі.
// Не забудь використати для цього зворотні лапки.

// // --------------------===================== Result =====================--------------------

// function makeStickers(detailsCount, robotPart) {
//     // write code here
//     let details = [];
//     for (let i = 1; i <= detailsCount; i++) {
//         details.push(robotPart + ` detail #` + i);
//     }
//     return details;
// }

// ###########################################################################################################################################################

// // ==========================================Task-11

// // --------------------===================== Conditions =====================--------------------

// Наліпки готові ? Добре, треба збільшити потужності наших ліній у два рази! До цього ми там тільки попкорн готували.

// Напиши функцію doublePower, яка приймає масив поточних потужностей currentPowers та повертає новий масив з подвоєними значеннями.

//     Приклади:

// doublePower([100, 150, 200, 220]) === [200, 300, 400, 440]
// doublePower([45, 34, 56, 67]) === [90, 68, 112, 134]
// doublePower([]) === []
// Підказка 1
// Створи порожній масив
// Використовуй цикл for від 0 до currentPowers.length(не включно), щоб перебрати вхідний масив
// На кожній ітерації додавай у масив i - й елемент currentPowers, помножений на 2
// Підказка 2
// Щоб отримати i - й елемент масиву, використовуй квадратні дужки(currentPowers[i])

// // --------------------===================== Result =====================--------------------

// function doublePower(currentPowers) {
//     let power = [];
//     for (let i = 0; i < currentPowers.length; i++) {
//         power.push(currentPowers[i] * 2);
//     }
//     return power;
// }

// ###########################################################################################################################################################

// // ==========================================Task-12

// // --------------------===================== Conditions =====================--------------------

// Давай навчимо наших роботів сортувати коробки на складі.Всі коробки мають номери, а роботи вчаться сортувати їх в порядку зростання.

// Але сортування — справа нелегка, іноді трапляються помилки.Тому нам поки доведеться перевіряти, чи правильно робот відсортував коробки.

// Напиши функцію isSorted, яка отримує масив чисел boxNumbers і повертає true, якщо всі числа в порядку зростання, або false, якщо це не так.
// Числа можуть повторюватись.

//     Приклади:

// isSorted([1, 2, 3, 4, 5]) === true
// isSorted([0, 1, 1, 1, 2]) === true
// isSorted([1, 2, 11]) === true
// isSorted([5]) === true
// isSorted([]) === true
// isSorted([0, 3, 1, 2, 2, 2]) === false
// isSorted([1, 11, 2]) === false
// Підказка
// Перебери масив, починаючи з другого елемента(щоб був попередній)
// На кожній ітерації порівнюй поточний елемент з попереднім
// Якщо поточний елемент менший за попередній, порядок неправильний, і можна завершити функцію —
// Якщо ми дійшли до кінця, значить, елементи впорядковані правильно

// // --------------------===================== Result =====================--------------------

// function isSorted(boxNumbers) {
//     for (let i = 1; i <= boxNumbers.length; i++) {
//         if (boxNumbers[i] < boxNumbers[i - 1]) {
//             return false
//         }
//     }
//     return true
// }

// ###########################################################################################################################################################

// // ==========================================Task-13

// // --------------------===================== Conditions =====================--------------------

// Наш робот вміє перетворювати команди руху на правильний сигнал і рухатися відповідно до нього:

// 'forward' означає y + 1
// 'back' означає y - 1
// 'right' означає x + 1
// 'left' означає x - 1
// Було б чудово, якби робот знав, де він зараз знаходиться навіть без GPS.

// Напиши функцію getLocation, яка приймає масив початкових координат coordinates(у вигляді[x, y]) та масив історії команд commands.

// Функція повинна повертати масив кінцевих координат робота в тому ж форматі([x, y]) після рухів відповідно до команд з commands.

//     Наприклад:

// coordinates = [2, 1]
// commands = ['left', 'back', 'back']

// Координати після першої команди: [1, 1] // 1 крок вліво
// Координати після другої команди: [1, 0] // 1 крок назад
// Координати після третьої команди: [1, -1] // 1 крок назад

// Результатом буде[1, -1]
// Інші приклади:

// getLocation([0, 0], ['forward', 'right']) === [1, 1]
// getLocation([2, 3], ['back', 'back', 'back', 'right']) === [3, 0]
// getLocation([0, 5], ['back', 'back', 'back', 'right', 'left', 'forward']) === [0, 3]
// Підказка
// Створи змінні x та y і присвой їм значення відповідних координат з масиву coordinates: ми змінюватимемо їх згідно з рухами робота
// Перебери масив commands
// На кожній ітерації перевіряй поточну команду:
// якщо вона дорівнює 'forward', збільшуй y на 1
// якщо вона дорівнює 'left', зменшуй x на 1, і так далі...
// Поверни масив з кінцевими значеннями x та y.

// // --------------------===================== Result =====================--------------------

// function getLocation(coordinates, commands) {
//     let x = coordinates[0];
//     let y = coordinates[1];
//     for (const command of commands) {
//         if (command === 'forward') {
//             y++;
//         }
//         if (command === 'back') {
//             y--;
//         }
//         if (command === 'right') {
//             x++;
//         }
//         if (command === 'left') {
//             x--;
//         }
//     }
//     return [x, y];
// }

// console.log(getLocation);

// ###########################################################################################################################################################

// // ==========================================Task-14

// // --------------------===================== Conditions =====================--------------------

// Ну що, коли всі процеси налаштовано, потрібно ставити перед собою правильні цілі.
// Наші роботи найкращі на ринку, тому потрібно нарощувати оберти і збільшувати обсяги виробництва.

// Напиши функцію getPlan, яка поверне масив з цілями на задану кількість місяців numberOfMonths.
// Зараз ми виготовляємо startProduction роботів на місяць і хочемо, щоб щомісяця це число зростало на заданий відсоток percent.

// Якщо кількість роботів буде не цілою, округли її вниз(Math.floor(value)).Ціль кожного наступного місяця розраховуй відносно попереднього.

//     Приклади:

// getPlan(200, 3, 50) === [300, 450, 675]
// getPlan(10, 4, 30) === [13, 16, 20, 26]
// getPlan(1000, 6, 20) === [1200, 1440, 1728, 2073, 2487, 2984]
// Підказка
// Створи порожній масив goals
// Створи змінну currentProduction з поточним виробництвом і присвой їй значення startProduction
// Перебери скільки потрібно місяців
// На кожній ітерації збільшуй currentProduction на заданий відсоток percent і додавай його в масив goals.

// // --------------------===================== Result =====================--------------------

// function getPlan(startProduction, numberOfMonths, percent) {
//     let goal = [];
//     let currentProduction = startProduction;
//     for (let i = 1; i <= numberOfMonths; i++) {
//         currentProduction += Math.floor((currentProduction) * percent / 100);
//         goal.push(currentProduction);
//     }
//     return goal;
// }

// ###########################################################################################################################################################

// // ==========================================Task-15

// // --------------------===================== Conditions =====================--------------------

// Перша партія роботів готова, тепер їх треба перевірити.Всі роботи унікальні, тому в кожного своя швидкість руху.
// Треба визначити найнижчу, найвищу та середню швидкість наших роботів.

// Наш сервер приймає масив швидкостей роботів testResults, пропускає його через функцію getSpeedStatistic
// і повертає статистику у вигляді масиву, де

// перший елемент - це мінімальна швидкість
// другий - максимальна
// третій - середнє значення всіх швидкостей з testResults, округлене вниз(використай Math.floor(result))
// Приклади:

// getSpeedStatistic([10, 10, 11, 9, 12, 8]) === [8, 12, 10]
// getSpeedStatistic([10]) === [10, 10, 10]
// getSpeedStatistic([]) === [0, 0, 0]
// getSpeedStatistic([8, 9, 3, 12]) === [3, 12, 8]
// getSpeedStatistic([5]) === [5, 5, 5]
// Підказка 1
// Якщо масив результатів порожній, одразу поверни статистику
// Створи змінні max, min та sum з першою швидкістю з масиву
// Перебери решту елементів з масиву
// На кожній ітерації:
// перевіряй, чи поточний елемент більший за max; якщо це так, присвой змінній max значення цього елементу
// перевіряй, чи поточний елемент менший за min; якщо це так, присвой змінній min значення цього елементу
// додавай поточний елемент до sum
// Після перебору обчисли значення average(і округли його вниз)
// Поверни масив з min, max та average
// Підказка 2
// Розділи Вибираємо один елемент з масиву та Обчислення середнього значення в теорії під відео допоможуть виконати цю задачу.

// // --------------------===================== Result =====================--------------------

// function getSpeedStatistic(testResults) {
//     if (testResults.length === 0) {
//         return [0, 0, 0];
//     }
//     let min = Math.min(...testResults);
//     let max = Math.max(...testResults);
//     let sum = 0;
//     for (let i = 0; i < testResults.length; i++) {
//         sum += testResults[i];
//     }
//     const average = sum / testResults.length
//     return [min, max, Math.floor(average)]
// }

// ###########################################################################################################################################################

// // ==========================================Task-16

// // --------------------===================== Conditions =====================--------------------

// Роботи протестовані.Повільні роботи відправлені на апгрейд.Mate Post хоче купити у нас десяток роботів для доставки вантажів по місту.
// Для цього їм потрібні роботи, які будуть переносити за день найбільшу сумарну вагу.

// Давай напишемо функцію compareRobots, яка приймає 2 масиви.Перший масив firstRobotResults містить вагу кожного вантажу,
// який перевіз за добу перший робот, другий secondRobotResults - відповідно вага вантажів другого робота.

// Перевір, хто з роботів перевіз більшу вагу за день, та поверни рядок з рекомендацією, кого з роботів варто купити(див.приклади).

// Приклади:

// compareRobots([12, 4, 13], [1, 1, 4, 5, 12]) === 'First robot for sale!' // 29 > 23
// compareRobots([9, 7, 9], [1, 3, 4, 5, 12]) === 'Both robots for sale!' // 25 = 25
// compareRobots([1, 3, 4], [1, 1, 4, 5]) === 'Second robot for sale!' // 8 < 11
// Як знайти суму усіх елементів масиву
// Створи змінну, яка будеш збільшувати під час перебору масиву
// Перебери масив, суму чисел якого хочеш знайти
// На кожній ітерації додавай поточний елемент до змінної.

// // --------------------===================== Result =====================--------------------

// function compareRobots(firstRobotResults, secondRobotResults) {
//     let firstRobotWeigh = 0;
//     let secondRobotWeigh = 0;
//     for (let i of firstRobotResults) {
//         firstRobotWeigh += i;
//     }

//     for (let x of secondRobotResults) {
//         secondRobotWeigh += x;
//     }

//     if (firstRobotWeigh > secondRobotWeigh) return 'First robot for sale!';
//     if (firstRobotWeigh < secondRobotWeigh) return 'Second robot for sale!';
//     return 'Both robots for sale!';
// }








// // --------------------===================== Result =====================--------------------