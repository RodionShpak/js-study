// ###########################################################################################################################################################

// // ==========================================Task-1

// Як отримати довжину рядка, збереженого у змінній 'input' ?

//     input.charAt()

// input.toUpperCase()

// input.length                        V

// input.count

// Пояснення правильного варіанту:
// У кожного рядка є довжина(кількість символів в ньому).
// Довжина записана у властивості length.
// Відповідно, для того, аби отримати довжину рядка, нам потрібно вказати назву змінної, довжину якої ми хочемо дізнатися, та 'length'

// ###########################################################################################################################################################

// // ==========================================Task-2

// Який результат наведеного нижче коду ?
// const fruit = 'apple';

// console.log(fruit[5]);

// ''

// 'e'

// undefined                           V

// 't'

// Пояснення правильного варіанту:
// Отримати окремий символ можна за його індексом(порядковим номером), що починається з 0.
// Наш рядок 'apple' має 5 символів, але оскільки рахунок починається з індексу 0, то останній символ буде із індексом 4.
// Таким чином, ми намагаємось знайти індекс, якого не існує і тому команда 'console.log(fruit[5])' виведе undefined

// ###########################################################################################################################################################

// // ==========================================Task-3

// Який результат наведеного нижче коду ?
//     let text = 'Hello world, welcome to the universe.';
// let result = text.indexOf('welcome');

// -1

// 13                          V

// 2

// 11

// Пояснення правильного варіанту:
// Метод 'indexOf()' допомагає визначити, на якому місці стоїть літера або цілий підрядок.
// 'indexOf()' повертає індекс першого входження вказаного значення в рядок та повертає '-1', якщо значення не знайдене.
// Цей метод має два параметри: 'searchValue' та 'fromIndex'.
// 'searchValue' – це, власне, і є значення, яке ми намагаємося знайти в рядку.В нашому випадку це 'welcome'
// Пошук позиції можна почати після певного індексу.
// Для цього необхідно в дужках першим параметром вказати слово, літеру, або рядок,
// який ми хочемо знайти та через кому другим параметром передати позицію, після якої ми хочемо шукати.
// Власне, другий параметр і називається 'fromIndex'.
// 'fromIndex' – це не обов'язковий параметр, який позначає розміщення в рядку та звідки починати пошук.
// Цей параметр може бути будь - яким цілим числом.За замовчуванням 'fromIndex' дорівнює 0.
// Якщо ж 'fromIndex' буде менше ніж 0, то пошук буде здійснюватися по всьому рядку(так само як би ми передавали 0).
//     Якщо 'fromIndex' більший або дорівнює довжині рядка, то 'indexOf()' поверне - 1.
// Приміром, ми в нашому рядку шукаємо те ж слово 'welcome', але хочемо знати чи знаходиться воно після 10 індексу.
// Наш код виглядатиме наступним чином: text.indexOf('welcome', 10) і нам повернеться 13.
// Якщо ж ми спробуємо ввести  text.indexOf('welcome', 20), то отримаємо - 1. Тому, що 'welcome' не з'являється після 20 позиції

// ###########################################################################################################################################################

// // ==========================================Task-4

// Який результат наведеного нижче коду ?
// const str = 'The quick brown fox jumps over the lazy dog.';

// console.log(str.slice(4, 10));

// 'jumps'

// 'fox jumps over the lazy dog'

// 'quick '                            V

// ''

// Пояснення правильного варіанту:
// Метод '.slice()' допомагає отримати частину рядка(підрядок) із основного рядка не змінюючи оригінальний рядок.
// У методу '.slice()' є два параметри: 'beginIndex' та 'endIndex'.
// 'beginIndex' – це індекс, який ми записуємо першим в дужках і з якого починається вилучення підрядка(нумерація починається із нуля).
// Якщо індекс має від'ємне значення, то рахунок починається із кінця рядка.
// Приміром, якщо ми введемо '.slice(-2)', то метод почне вилучати підрядок із другого елемента в кінці рядка.
// Якщо 'beginIndex' не є числом, то він буде трактуватися як 0 і вилучення почнеться із самого початку рядка.
// Якщо ж 'beginIndex' більший або дорівнює довжині рядка, то метод поверне пустий рядок.
// 'endIndex' – це індекс, перед яким завершується вилучення підрядка(нумерація починається з нуля).
// Варто пам'ятати, що символ із цим індексом не буде включено до підрядка.
// Якщо 'endIndex' упущений, undefined або більший за довжину рядка, то '.slice()' вилучить все до самого кінця рядка.
// Якщо 'endIndex' вказаний, але менший за 'beginIndex', то  '.slice()' поверне пустий рядок.Наприклад, 'slice(7, 4)' поверне ' '

// ###########################################################################################################################################################

// // ==========================================Task-5

// Що перевіряє код, наведений нижче ?
//     function isLetter(ch) {
//         return ch.toLowerCase() !== ch.toUpperCase();
//     }

// Що 'ch' не у верхньому регістрі

// Що 'ch' – це число

// Що 'ch' в нижньому регістрі

// Що 'ch' – це літера                  V

// Пояснення правильного варіанту:
// В JavaScript можна перевірити, чи є символ літерою чи ні.
// Зробити це можна за допомогою приведення рядка до нижнього регістру та перевіркою,
// чи цей рядок в нижньому регістрі відповідає рядку у верхньому регістрі.
// Якщо не відповідає, то цей символ - літера і 'console.log()' поверне true.
// Якщо це інший символ, наприклад, число, то перевірка поверне false, тому що числа у верхньому та нижньому регістрах будуть однакові

// ###########################################################################################################################################################

// // ==========================================Task-6

// Який результат наведеного нижче коду ?
// const string = 'banana';

// for (const char of string) {
//     console.log(char);
// }

// 'b', 'a', 'n', 'a', 'n', 'a'               V

// 'a', 'n', 'a', 'n', 'a', 'b'

// 'ananab'

// 'banana'

// Пояснення правильного варіанту:
// Для того, щоб перебрати всі символи в рядку незалежно від індексу чудово підходить цикл 'for of'.
// Він не потребує перевірок та зміни індексу, до того ж пишеться набагато швидше.
// Якщо брати наш приклад то, ми просто перебираємо кожен символ в рядку по черзі, а 'console.log()' виводить нам всі ці символи один за одним

// ###########################################################################################################################################################

// // ==========================================Task-7

// Який остаточний результат наведеного нижче коду ?
// const string = 'Do you have any hobbies?';
// let result = '';

// for (const char of string) {
//     if (char !== ' ') {
//         result += char;
//     }
//     console.log(result);
// }

// 'Doyouhaveanyhobbies?'                     V

// 'Do you have any hobbies?'

// undefined

// ''

// Пояснення правильного варіанту:
// В рядках можна не лише шукати індекси, слова та підрядки, також в нас є можливість модифікувати рядок.
// В нашому коді ми видаляємо пробіли.Як це саме відбувається ?
// Перед тим, як написати цикл, який буде перебирати наш рядок, для зручності ми оголошуємо змінну 'result', в яку будемо записувати наш новий рядок.
// Далі ми пишемо сам цикл.Оскільки в нашому випадку індекси не важливі, ми використовуємо цикл 'for of'.
// В тілі циклу ми записуємо умову: якщо наш цикл знаходить символ, який не є пробілом, то ми його додаємо до результату.
// І в кінці ми виводимо сам результат.
// Наприклад, при першій ітерації ми знаходимо літеру 'D'.Далі ми переходимо до умови і перевіряємо чи наша знайдена літера не пробіл.
// Ми бачимо, що вона не пробіл і додаємо її до результату.
// Все те ж саме відбувається й під час другої ітерації, коли ми знаходимо літеру 'o'.
// Під час третьої ітерації наш цикл знаходить пробіл.Далі він перевіряє умову.
// Наша умова виявляється false і в такому випадку ми нічого не додаємо до результату і просто переходимо до наступної ітерації.
// І так відбувається, поки ми не переберемо весь рядок

// ###########################################################################################################################################################

// // ==========================================Task-8

// // --------------------===================== Сonditions --------------------=====================
// Напиши функцію getStringLength, яка приймає рядок input та повертає його довжину.

// // --------------------===================== Result --------------------=====================

// /**
//  * @param {string} input
//  *
//  * @returns {number}
//  */
// function getStringLength(input) {
//     return input.length;
// }

// ###########################################################################################################################################################

// // ==========================================Task-9

// // --------------------===================== Сonditions --------------------=====================

// Створи функцію isSubstring, яка приймає два параметри: phrase і part.
// Функція повинна повертати true, якщо phrase містить part, якщо ні - потрібно повертати false.

// Функція має враховувати регістр.

//     Приклади:

// isSubstring('string', 's') === true
// isSubstring('string', 'ring') === true
// isSubstring('string', 'bring') === false
// isSubstring('string', 'Str') === false // 'str' і 'Str' - різні рядки в цьому завданні
// Підказка
// Ти можеш скористатися методом includes, щоб виконати це завдання.

// // --------------------===================== Result --------------------=====================

// function isSubstring(phrase, part) {
//     if (phrase.includes(part)) {
//         return true;
//     } else {
//         return false;
//     }
// }

// ###########################################################################################################################################################

// // ==========================================Task-10

// // --------------------===================== Сonditions --------------------=====================

// Створи функцію countMs, яка приймає рядок text і повертає кількість літер 'm' у ньому(як великих, так і маленьких разом).

//     Приклади:

// countMs('document') === 1
// countMs('Mermaid') === 2 // потрібно рахувати і 'm', і 'M'
// countMs('code') === 0

// Підказка 1
// Створи змінну count
// Створи цикл for of, який буде перебирати кожний символ в text
// На кожній ітерації перевіряй, чи поточний символ дорівнює 'm' або 'M': якщо це так, збільшуй count на 1

// Підказка 2
// Розділ Перебір без індекса в теорії під відео допоможе тобі написати цикл for of.

// // --------------------===================== Result --------------------=====================

// function countMs(text) {
//     let count = 0;
//     for (let i of text) {
//         if (i === `M` || i === `m`) {
//             count++;
//         }
//     }
//     return count;
// }

// ###########################################################################################################################################################

// // ==========================================Task-11

// // --------------------===================== Сonditions --------------------=====================

// Наш новий бос, як виявилося, просто ненавидить голосні літери, тому нам потрібно прибрати їх з усієї документації.

// Напиши функцію removeVowels, яка приймає рядок doc і повертає рядок, де усі голосні з doc видалені.

// Голосними для цього завдання вважаються букви aeiouy в будь - якому регістрі.

//     Приклади:

// removeVowels('document') === 'dcmnt'
// removeVowels('I like my boss') === ' lk m bss'
// removeVowels('350 euro') === '350 r'
// Підказка
// Створи змінну result
// Створи цикл for of, який буде перебирати кожний символ в doc
// На кожній ітерації перевіряй, чи поточний символ НЕ є голосною: якщо це так, додавай поточний символ до result

// // --------------------===================== Result --------------------=====================

// function removeVowels(doc) {
//     const audit = 'aeiouyAEIOUY';
//     let result = '';
//     for (let i of doc) {
//         result += audit.includes(i) ? '' : i;
//     }
//     return result;
// }

// ###########################################################################################################################################################

// // ==========================================Task-12

// // --------------------===================== Сonditions --------------------=====================

// Створи функцію makeAbbr, яка приймає рядок зі слів words і повертає абревіатуру з них у верхньому регістрі.

// Рядок words містить одне або декілька слів, розділених одним пробілом.

//     Приклади:

// makeAbbr('national aeronautics space administration') === 'NASA'
// makeAbbr('central processing unit') === 'CPU'
// makeAbbr('simplified molecular input line entry specification') === 'SMILES'
// Підказка 1
// Створи змінну abbreviation та присвой їй значення першого символу рядка words
// Створи цикл for, який буде перебирати кожен символ words
// На кожній ітерації перевіряй, чи є поточний символ пробілом: якщо це так, додавай НАСТУПНИЙ символ до abbreviation
// Підказка 2
// Не забудь, що результат має бути у верхньому регістрі: для цього можна використати метод toUpperCase.

// // --------------------===================== Result --------------------=====================

// function makeAbbr(words) {
//     const name = ` ${words.trim()}`
//     let abbreviation = '';
//     for (let i = 0; i < name.length; i++) {
//         if (name[i] === ' ') {
//             abbreviation += name[i + 1];
//         }
//     }
//     return abbreviation.toUpperCase();
// }

// ###########################################################################################################################################################

// // ==========================================Task-13

// // --------------------===================== Сonditions --------------------=====================

// Створи функцію decryptMessage, яка приймає рядок message і повертає рядок, де символи з message розташовані у зворотному порядку.

//     Приклади:

// decryptMessage('!!!reeb gniknird ekil eW') === 'We like drinking beer!!!'
// decryptMessage('0202 ni eb lliw cimednap surivanoroc A') === 'A coronavirus pandemic will be in 2020'
// Підказка 1
// Створи змінну result
// Створи цикл for, який буде перебирати кожний символ в message, починаючи з останнього символу і рухаючись назад
// На кожній ітерації додавай поточний символ до result
// Підказка 2
// Щоб отримати індекс останнього символу рядка, використовуй message.length - 1
// Щоб рухатися від останнього до першого символу, зменшуй індекс на 1 в кроці циклу.

// // --------------------===================== Result --------------------=====================

// function decryptMessage(message) {
//     let result = '';
//     for (let i = message.length - 1; i >= 0; i--) {
//         result += message[i];
//     }
//     return result;
// }

// ###########################################################################################################################################################

// // ==========================================Task-14

// // --------------------===================== Сonditions --------------------=====================

// Створи функцію isWerewolf, яка приймає рядок target і повертає true, якщо це перевертень, або false, якщо це не так.

//     Перевертень — це слово або речення, яке читається в обох напрямках однаково, при цьому ігноруючи регістр, пробіли і розділові знаки.

//         Приклади:

// isWerewolf('rotator') === true // rotator --> rotator
// isWerewolf('home') === false // home --> emoh
// isWerewolf('Racecar') === true // регістр ігнорується
// isWerewolf('eva, can i see bees in a cave') === true // пробіли і розділові знаки ігноруються

// Підказка
// Створи змінну direct, де будуть зберігатися всі літери з target в прямому порядку
// Створи змінну reversed, де будуть зберігатися всі літери з target у зворотному порядку
// Створи цикл for of, який буде перебирати кожен символ в target
// На кожній ітерації перевіряй, чи є поточний символ літерою; якщо це так:
// додавай поточний символ в кінець direct
// додавай поточний символ на початок reversed
// Перевір, чи direct дорівнюєreversed; пам'ятай, що для коректної перевірки вони повинні бути в одному регістрі.

// // --------------------===================== Result --------------------=====================

// function isWerewolf(target) {
//     let direct = '';
//     let reserved = '';
//     for (let ch of target) {
//         if (ch.toLowerCase() !== ch.toUpperCase()) {
//             direct += ch;
//             reserved = ch + reserved;
//         }
//     }
//     return direct.toLowerCase() === reserved.toLowerCase();
// }

// ###########################################################################################################################################################

// // ==========================================Task-15

// // --------------------===================== Сonditions --------------------=====================

// Ми удосконалили нашу програму для збору статистики з вебінарів Міші.
// Тепер після збору статистики, вона відправляє дані на сервер у вигляді рядка 111001010111011,
// де 1 - це студент, який зрозумів тему, а 0 - відповідно, ні.

// Було б корисно розуміти скільки відсотків групи засвоїли матеріал, це покаже наскільки вебінар був ефективний.

// Створи функцію getSuccessRate, яка приймає рядок statistic та повертає відсоток студентів, які зрозуміли матеріал,
// округляючи до найближчого цілого(використай Math.round(result) для округления).

//     Приклади:

// getSuccessRate('11100') === 60
// getSuccessRate('1100') === 50
// getSuccessRate('000000') === 0
// getSuccessRate('11111') === 100
// getSuccessRate('') === 0

// // --------------------===================== Result --------------------=====================

// function getSuccessRate(statistic) {
//     if (statistic.length === 0) {
//         return 0;
//     }
//     let count = 0;
//     for (let i = 0; i < statistic.length; i++) {
//         if (statistic[i] === '1') {
//             count++;
//         }
//         console.log(count);
//     }
//     let final = (100 / statistic.length) * count;
//     return Math.round(final);
// }

